"""
This type stub file was generated by pyright.
"""

import collections

"""Operators specific to data structures: list append, subscripts, etc."""
def new_list(iterable=...): # -> list[Any] | Any:
  """The list constructor.

  Args:
    iterable: Optional elements to fill the list with.

  Returns:
    A list-like object. The exact return value depends on the initial elements.
  """
  ...

def tf_tensor_array_new(elements, element_dtype=..., element_shape=...): # -> TensorArray:
  """Overload of new_list that stages a Tensor list creation."""
  ...

def tf_tensor_list_new(elements, element_dtype=..., element_shape=...): # -> Any:
  """Overload of new_list that stages a Tensor list creation."""
  ...

def list_append(list_, x): # -> TensorArray | Any:
  """The list append function.

  Note: it is unspecified where list_ will be mutated or not. If list_ is
  a TensorFlow entity, it will not be typically mutated. If list_ is a plain
  list, it will be. In general, if the list is mutated then the return value
  should point to the original entity.

  Args:
    list_: An entity that supports append semantics.
    x: The element to append.

  Returns:
    Same as list_, after the append was performed.

  Raises:
    ValueError: if list_ is not of a known list-like type.
  """
  ...

class ListPopOpts(collections.namedtuple('ListPopOpts', ('element_dtype', 'element_shape'))):
  ...


def list_pop(list_, i, opts): # -> tuple[Any, Any]:
  """The list pop function.

  Note: it is unspecified where list_ will be mutated or not. If list_ is
  a TensorFlow entity, it will not be typically mutated. If list_ is a plain
  list, it will be. In general, if the list is mutated then the return value
  should point to the original entity.

  Args:
    list_: An entity that supports pop semantics.
    i: Optional index to pop from. May be None.
    opts: A ListPopOpts.

  Returns:
    Tuple (x, out_list_):
      out_list_: same as list_, after the removal was performed.
      x: the removed element value.

  Raises:
    ValueError: if list_ is not of a known list-like type or the operation is
    not supported for that type.
  """
  ...

class ListStackOpts(collections.namedtuple('ListStackOpts', ('element_dtype', 'original_call'))):
  ...


def list_stack(list_, opts): # -> SymbolicTensor | Any:
  """The list stack function.

  This does not have a direct correspondent in Python. The closest idiom to
  this is tf.append or np.stack. It's different from those in the sense that it
  accepts a Tensor list, rather than a list of tensors. It can also accept
  TensorArray. When the target is anything else, the dispatcher will rely on
  ctx.original_call for fallback.

  Args:
    list_: An entity that supports append semantics.
    opts: A ListStackOpts object.

  Returns:
    The output of the stack operation, typically a Tensor.
  """
  ...

