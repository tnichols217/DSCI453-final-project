"""
This type stub file was generated by pyright.
"""

from tensorflow.python.autograph.pyct import cfg, transformer

"""Reaching definition analysis.

This analysis attaches a set of a Definition objects to each symbol, one
for each distinct definition that may reach it. The Definition objects are
mutable and may be used by subsequent analyses to further annotate data like
static type and value information.
The analysis also attaches the set of the symbols defined at the entry of
control flow statements.

Requires activity analysis.
"""
class Definition:
  """Definition objects describe a unique definition of a variable.

  Subclasses of this may be used by passing an appropriate factory function to
  resolve.

  Attributes:
    param_of: Optional[ast.AST]
    directives: Dict, optional definition annotations
  """
  def __init__(self) -> None:
    ...
  
  def __repr__(self): # -> str:
    ...
  


class _NodeState:
  """Abstraction for the state of the CFG walk for reaching definition analysis.

  This is a value type. Only implements the strictly necessary operators.

  Attributes:
    value: Dict[qual_names.QN, Set[Definition, ...]], the defined symbols and
        their possible definitions
  """
  def __init__(self, init_from=...) -> None:
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __ne__(self, other) -> bool:
    ...
  
  def __or__(self, other): # -> _NodeState:
    ...
  
  def __sub__(self, other): # -> _NodeState:
    ...
  
  def __repr__(self): # -> str:
    ...
  


class Analyzer(cfg.GraphVisitor):
  """CFG visitor that determines reaching definitions at statement level."""
  def __init__(self, graph, definition_factory) -> None:
    ...
  
  def init_state(self, _): # -> _NodeState:
    ...
  
  def visit_node(self, node):
    ...
  


class TreeAnnotator(transformer.Base):
  """AST visitor that annotates each symbol name with its reaching definitions.

  Simultaneously, the visitor runs the dataflow analysis on each function node,
  accounting for the effect of closures. For example:

    def foo():
      bar = 1
      def baz():
        # bar = 1 reaches here
  """
  def __init__(self, source_info, graphs, definition_factory) -> None:
    ...
  
  def visit_FunctionDef(self, node): # -> FunctionDef:
    ...
  
  def visit_Name(self, node): # -> Name:
    ...
  
  def visit_If(self, node): # -> AST:
    ...
  
  def visit_For(self, node): # -> For:
    ...
  
  def visit_While(self, node): # -> AST:
    ...
  
  def visit_Try(self, node): # -> AST:
    ...
  
  def visit_ExceptHandler(self, node): # -> ExceptHandler:
    ...
  
  def visit(self, node): # -> AST | list[Any] | tuple[Any, ...] | Any:
    ...
  


def resolve(node, source_info, graphs, definition_factory=...): # -> AST | list[Any] | tuple[Any, ...] | Any:
  """Resolves reaching definitions for each symbol.

  Args:
    node: ast.AST
    source_info: transformer.SourceInfo
    graphs: Dict[ast.FunctionDef, cfg.Graph]
    definition_factory: Callable[[], Definition]
  Returns:
    ast.AST
  """
  ...

