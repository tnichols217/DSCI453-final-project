"""
This type stub file was generated by pyright.
"""

import collections
import enum
import gast

"""Control flow graph (CFG) structure for Python AST representation.

The CFG is a digraph with edges representing valid control flow. Each
node is associated with exactly one AST node, but not all AST nodes may have
a corresponding CFG counterpart.

Once built, the CFG itself is immutable, but the values it holds need not be;
they are usually annotated with information extracted by walking the graph.

Tip: Use `Graph.as_dot` to visualize the CFG using any DOT viewer.

Note: the CFG tries to include all code paths that MAY be taken, with a single
notable exception:
 * function calls do not generate edges corresponding to exceptions they may
   raise (i.e. a function call in the middle of a block does not return or jump
   to any except or finally block)
TODO(mdan): Consider adding the edges above. They'd only add ~O(n) edges.
TODO(mdan): Alternatively, consider adding an edge from try to all its excepts.
"""
class Node:
  """A node in the CFG.

  Although new instances of this class are mutable, the objects that a user
  finds in the CFG are typically not.

  The nodes represent edges in the CFG graph, and maintain pointers to allow
  efficient walking in both forward and reverse order. The following property
  holds for all nodes: "child in node.next" iff "node in child.prev".

  Attributes:
    next: FrozenSet[Node, ...], the nodes that follow this node, in control flow
      order
    prev: FrozenSet[Node, ...], the nodes that precede this node, in reverse
      control flow order
    ast_node: ast.AST, the AST node corresponding to this CFG node
  """
  def __init__(self, next_, prev, ast_node) -> None:
    ...
  
  def freeze(self): # -> None:
    ...
  
  def __repr__(self): # -> str:
    ...
  


class Graph(collections.namedtuple('Graph', ['entry', 'exit', 'error', 'index', 'stmt_prev', 'stmt_next'])):
  """A Control Flow Graph.

  The CFG maintains an index to allow looking up a CFG node by the AST node to
  which it is associated. The index can also be enumerated in top-down, depth
  first order.

  Walking the graph in forward or reverse order is supported by double
  parent-child links.

  Note: the error nodes are not wired to their corresponding finally guards,
  because these are shared, and wiring them would create a reverse path from
  normal control flow into the error nodes, which we want to avoid.

  The graph also maintains edges corresponding to higher level statements
  like for-else loops. A node is considered successor of a statement if there
  is an edge from a node that is lexically a child of that statement to a node
  that is not. Statement predecessors are analogously defined.

  Attributes:
    entry: Node, the entry node
    exit: FrozenSet[Node, ...], the exit nodes
    error: FrozenSet[Node, ...], nodes that exit due to an explicitly raised
      error (errors propagated from function calls are not accounted)
    index: Dict[ast.Node, Node], mapping AST nodes to the respective CFG node
    stmt_prev: Dict[ast.Node, FrozenSet[Node, ...]], mapping statement AST nodes
      to their predecessor CFG nodes
    stmt_next: Dict[ast.Node, FrozenSet[Node, ...]], mapping statement AST nodes
      to their successor CFG nodes
  """
  def __repr__(self): # -> str:
    ...
  
  def as_dot(self): # -> str:
    """Print CFG in DOT format."""
    ...
  


class _WalkMode(enum.Enum):
  FORWARD = ...
  REVERSE = ...


class GraphVisitor:
  """Base class for a CFG visitors.

  This implementation is not thread safe.

  The visitor has some facilities to simplify dataflow analyses. In particular,
  it allows revisiting the nodes at the decision of the subclass. This can be
  used to visit the graph until the state reaches a fixed point.

  For more details on dataflow analysis, see
  https://www.seas.harvard.edu/courses/cs252/2011sp/slides/Lec02-Dataflow.pdf

  Note: the literature generally suggests visiting successor nodes only when the
  state of the current node changed, regardless of whether that successor has
  ever been visited. This implementation visits every successor at least once.

  Attributes:
    graph: Graph
    in_: Dict[Node, Any], stores node-keyed state during a visit
    out: Dict[Node, Any], stores node-keyed state during a visit
  """
  def __init__(self, graph) -> None:
    ...
  
  def init_state(self, node):
    """State initialization function.

    Optional to overload.

    An in/out state slot will be created for each node in the graph. Subclasses
    must overload this to control what that is initialized to.

    Args:
      node: Node
    """
    ...
  
  def visit_node(self, node):
    """Visitor function.

    Args:
      node: Node

    Returns:
      bool, whether the node should be revisited; subclasses can visit every
          reachable node exactly once by always returning False
    """
    ...
  
  def reset(self): # -> None:
    ...
  
  def can_ignore(self, node): # -> bool:
    """Returns True if the node can safely be assumed not to touch variables."""
    ...
  
  def visit_forward(self): # -> None:
    ...
  
  def visit_reverse(self): # -> None:
    ...
  


class GraphBuilder:
  """Builder that constructs a CFG from a given AST.

  This GraphBuilder facilitates constructing the DAG that forms the CFG when
  nodes
  are supplied in lexical order (i.e., top-down, depth first). Under these
  conditions, it supports building patterns found in typical structured
  programs.

  This builder ignores the flow generated by exceptions, which are assumed to
  always be catastrophic and present purely for diagnostic purposes (e.g. to
  print debug information). Statements like raise and try/catch sections are
  allowed and will generate control flow edges, but ordinary statements are
  assumed not to raise exceptions.

  Finally sections are also correctly interleaved between break/continue/return
  nodes and their subsequent statements.

  Important concepts:
   * nodes - nodes refer to CFG nodes; AST nodes are qualified explicitly
   * leaf set - since the graph is constructed gradually, a leaf set maintains
     the CFG nodes that will precede the node that the builder expects to
     receive next; when an ordinary node is added, it is connected to the
     existing leaves and it in turn becomes the new leaf
   * jump nodes - nodes that should generate edges other than what
     ordinary nodes would; these correspond to break, continue and return
     statements
   * sections - logical delimiters for subgraphs that require special
     edges; there are various types of nodes, each admitting various
     types of jump nodes; sections are identified by their corresponding AST
     node
  """
  def __init__(self, parent_ast_node) -> None:
    ...
  
  def reset(self): # -> None:
    """Resets the state of this factory."""
    ...
  
  def begin_statement(self, stmt): # -> None:
    """Marks the beginning of a statement.

    Args:
      stmt: Hashable, a key by which the statement can be identified in the
        CFG's stmt_prev and stmt_next attributes
    """
    ...
  
  def end_statement(self, stmt): # -> None:
    """Marks the end of a statement.

    Args:
      stmt: Hashable, a key by which the statement can be identified in the
        CFG's stmt_prev and stmt_next attributes; must match a key previously
        passed to begin_statement.
    """
    ...
  
  def add_ordinary_node(self, ast_node): # -> Node:
    """Grows the graph by adding an ordinary CFG node.

    Ordinary nodes are followed by the next node, in lexical order, that is,
    they become the new leaf set.

    Args:
      ast_node: ast.AST

    Returns:
      Node
    """
    ...
  
  def add_exit_node(self, ast_node, section_id, guards): # -> Node:
    """Grows the graph by adding an exit node.

    This node becomes an exit for the current section.

    Args:
      ast_node: ast.AST
      section_id: Hashable, the node for which ast_node should be considered to
        be an exit node
      guards: Tuple[ast.AST, ...], the finally sections that guard ast_node

    Returns:
      Node
    """
    ...
  
  def add_continue_node(self, ast_node, section_id, guards): # -> None:
    """Grows the graph by adding a reentry node.

    This node causes control flow to go back to the loop section's entry.

    Args:
      ast_node: ast.AST
      section_id: Hashable, the node for which ast_node should be considered to
        be an exit node
      guards: Tuple[ast.AST, ...], the finally sections that guard ast_node
    """
    ...
  
  def connect_raise_node(self, node, except_guards): # -> None:
    """Adds extra connection between a raise node and containing except guards.

    The node is a graph node, not an ast node.

    Args:
      node: Node
      except_guards: Tuple[ast.AST, ...], the except sections that guard node
    """
    ...
  
  def enter_section(self, section_id): # -> None:
    """Enters a regular section.

    Regular sections admit exit jumps, which end the section.

    Args:
      section_id: Hashable, the same node that will be used in calls to the
        ast_node arg passed to add_exit_node
    """
    ...
  
  def exit_section(self, section_id): # -> None:
    """Exits a regular section."""
    ...
  
  def enter_loop_section(self, section_id, entry_node): # -> None:
    """Enters a loop section.

    Loop sections define an entry node. The end of the section always flows back
    to the entry node. These admit continue jump nodes which also flow to the
    entry node.

    Args:
      section_id: Hashable, the same node that will be used in calls to the
        ast_node arg passed to add_continue_node
      entry_node: ast.AST, the entry node into the loop (e.g. the test node for
        while loops)
    """
    ...
  
  def exit_loop_section(self, section_id): # -> None:
    """Exits a loop section."""
    ...
  
  def enter_cond_section(self, section_id): # -> None:
    """Enters a conditional section.

    Conditional sections define an entry node, and one or more branches.

    Args:
      section_id: Hashable, the same node that will be used in calls to the
        section_id arg passed to new_cond_branch
    """
    ...
  
  def new_cond_branch(self, section_id): # -> None:
    """Begins a new branch in a cond section."""
    ...
  
  def exit_cond_section(self, section_id): # -> None:
    """Exits a conditional section."""
    ...
  
  def enter_except_section(self, section_id): # -> None:
    """Enters an except section."""
    ...
  
  def enter_finally_section(self, section_id): # -> None:
    """Enters a finally section."""
    ...
  
  def exit_finally_section(self, section_id): # -> None:
    """Exits a finally section."""
    ...
  
  def build(self): # -> Graph:
    """Returns the CFG accumulated so far and resets the builder.

    Returns:
      Graph
    """
    ...
  


class AstToCfg(gast.NodeVisitor):
  """Converts an AST to CFGs.

  A separate CFG will be constructed for each function.
  """
  def __init__(self) -> None:
    ...
  
  def visit_ClassDef(self, node): # -> None:
    ...
  
  def visit_FunctionDef(self, node): # -> None:
    ...
  
  def visit_Lambda(self, node): # -> None:
    ...
  
  def visit_Return(self, node): # -> None:
    ...
  
  def visit_Import(self, node): # -> None:
    ...
  
  def visit_ImportFrom(self, node): # -> None:
    ...
  
  def visit_Expr(self, node): # -> None:
    ...
  
  def visit_NamedExpr(self, node): # -> None:
    ...
  
  def visit_Assign(self, node): # -> None:
    ...
  
  def visit_AnnAssign(self, node): # -> None:
    ...
  
  def visit_AugAssign(self, node): # -> None:
    ...
  
  def visit_Pass(self, node): # -> None:
    ...
  
  def visit_Global(self, node): # -> None:
    ...
  
  def visit_Nonlocal(self, node): # -> None:
    ...
  
  def visit_Print(self, node): # -> None:
    ...
  
  def visit_Raise(self, node): # -> None:
    ...
  
  def visit_Assert(self, node): # -> None:
    ...
  
  def visit_Delete(self, node): # -> None:
    ...
  
  def visit_If(self, node): # -> None:
    ...
  
  def visit_While(self, node): # -> None:
    ...
  
  def visit_For(self, node): # -> None:
    ...
  
  def visit_Break(self, node): # -> None:
    ...
  
  def visit_Continue(self, node): # -> None:
    ...
  
  def visit_ExceptHandler(self, node): # -> None:
    ...
  
  def visit_Try(self, node): # -> None:
    ...
  
  def visit_With(self, node): # -> None:
    ...
  


def build(node): # -> dict[Any, Any]:
  ...

