"""
This type stub file was generated by pyright.
"""

import enum
from tensorflow.python.autograph.pyct import transformer
from tensorflow.python.util.tf_export import tf_export

"""Converter construction support.

This module contains a base class for all converters, as well as supporting
structures. These structures are referred to as contexts.

The class hierarchy is as follows:

    <your converter>
      [extends] converter.Base
        [extends] transformer.Base
            [extends] gast.nodeTransformer
          [uses] transformer.SourceInfo
        [uses] converter.EntityContext
          [uses] converter.ProgramContext
          [uses] transformer.SourceInfo

converter.Base is a specialization of transformer.Base for AutoGraph. It's a
very lightweight subclass that adds a `ctx` attribute holding the corresponding
EntityContext object (see below). Note that converters are not reusable, and
`visit` will raise an error if called more than once.

converter.EntityContext contains mutable state associated with an entity that
the converter processes.

converter.ProgramContext contains mutable state across related entities. For
example, when converting several functions that call one another, the
ProgramContext should be shared across these entities.

Below is the overall flow at conversion:

    program_ctx = ProgramContext(<entities to convert>, <global settings>, ...)
    while <program_ctx has more entities to convert>:
      entity, source_info = <get next entity from program_ctx>
      entity_ctx = EntityContext(program_ctx, source_info)
      for <each ConverterClass>:
        converter = ConverterClass(entity_ctx)

        # May update entity_ctx and program_ctx
        entity = converter.visit(entity)

      <add entity's dependencies to program_ctx>

Note that pyct contains a small number of transformers used for static analysis.
These implement transformer.Base, rather than converter.Base, to avoid a
dependency on AutoGraph.
"""
@tf_export('autograph.experimental.Feature')
class Feature(enum.Enum):
  """This enumeration represents optional conversion options.

  These conversion options are experimental. They are subject to change without
  notice and offer no guarantees.

  _Example Usage_

  ```python
  optionals= tf.autograph.experimental.Feature.EQUALITY_OPERATORS
  @tf.function(experimental_autograph_options=optionals)
  def f(i):
    if i == 0:  # EQUALITY_OPERATORS allows the use of == here.
      tf.print('i is zero')
  ```

  Attributes:
    ALL: Enable all features.
    AUTO_CONTROL_DEPS: Insert of control dependencies in the generated code.
    ASSERT_STATEMENTS: Convert Tensor-dependent assert statements to tf.Assert.
    BUILTIN_FUNCTIONS: Convert builtin functions applied to Tensors to
      their TF counterparts.
    EQUALITY_OPERATORS: Whether to convert the equality operator ('==') to
      tf.math.equal.
    LISTS: Convert list idioms, like initializers, slices, append, etc.
    NAME_SCOPES: Insert name scopes that name ops according to context, like the
      function they were defined in.
  """
  ALL = ...
  AUTO_CONTROL_DEPS = ...
  ASSERT_STATEMENTS = ...
  BUILTIN_FUNCTIONS = ...
  EQUALITY_OPERATORS = ...
  LISTS = ...
  NAME_SCOPES = ...
  @classmethod
  def all(cls): # -> tuple[Feature, ...]:
    """Returns a tuple that enables all options."""
    ...
  
  @classmethod
  def all_but(cls, exclude): # -> tuple[Feature, ...]:
    """Returns a tuple that enables all but the excluded options."""
    ...
  


STANDARD_OPTIONS = ...
class ConversionOptions:
  """Immutable container for global conversion flags.

  Attributes:
    recursive: bool, whether to recursively convert any user functions or
      classes that the converted function may use.
    user_requested: bool, whether the conversion was explicitly requested by
      the user, as opposed to being performed as a result of other logic. This
      value always auto-resets to False in child conversions.
    optional_features: Union[Feature, Set[Feature]], controls the use of
      optional features in the conversion process. See Feature for available
      options.
  """
  def __init__(self, recursive=..., user_requested=..., internal_convert_user_code=..., optional_features=...) -> None:
    ...
  
  def as_tuple(self): # -> tuple[bool, bool, bool, frozenset[Feature]]:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __str__(self) -> str:
    ...
  
  def uses(self, feature): # -> bool:
    ...
  
  def call_options(self): # -> ConversionOptions:
    """Returns the corresponding options to be used for recursive conversion."""
    ...
  
  def to_ast(self): # -> Any:
    """Returns a representation of this object as an AST node.

    The AST node encodes a constructor that would create an object with the
    same contents.

    Returns:
      ast.Node
    """
    ...
  


STANDARD_OPTIONS = ...
class ProgramContext:
  """ProgramContext keeps track of converting function hierarchies.

  Attributes:
    options: ConversionOptions
    autograph_module: Deprecated. Do not use.
  """
  def __init__(self, options, autograph_module=...) -> None:
    ...
  


class Base(transformer.Base):
  """All converters should inherit from this class.

  Attributes:
    ctx: EntityContext
  """
  def __init__(self, ctx) -> None:
    ...
  
  def get_definition_directive(self, node, directive, arg, default):
    """Returns the unique directive argument for a symbol.

    See lang/directives.py for details on directives.

    Example:
       # Given a directive in the code:
       ag.foo_directive(bar, baz=1)

       # One can write for an AST node Name(id='bar'):
       get_definition_directive(node, ag.foo_directive, 'baz')

    Args:
      node: ast.AST, the node representing the symbol for which the directive
        argument is needed.
      directive: Callable[..., Any], the directive to search.
      arg: str, the directive argument to return.
      default: Any

    Raises:
      ValueError: if conflicting annotations have been found
    """
    ...
  
  def visit(self, node): # -> AST | list[Any] | tuple[Any, ...] | Any:
    ...
  


