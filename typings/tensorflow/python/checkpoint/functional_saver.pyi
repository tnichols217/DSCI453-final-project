"""
This type stub file was generated by pyright.
"""

from typing import Callable, Mapping, Sequence
from tensorflow.core.protobuf import saver_pb2
from tensorflow.python.checkpoint import checkpoint_options
from tensorflow.python.checkpoint.sharding import sharding_util
from tensorflow.python.framework import ops, tensor as tensor_lib
from tensorflow.python.saved_model import registration
from tensorflow.python.trackable import base
from tensorflow.python.types import core

"""Saves and restore variables inside traced @tf.functions."""
RegisteredSaversDict = Mapping[registration.RegisteredSaver, Mapping[str, base.Trackable]]
MappedCapturesCallable = Callable[[core.ConcreteFunction, Sequence[tensor_lib.Tensor]], tensor_lib.Tensor]
def sharded_filename(filename_tensor: tensor_lib.Tensor, shard: int, num_shards: tensor_lib.Tensor) -> tensor_lib.Tensor:
  """Append sharding information to a filename.

  Args:
    filename_tensor: A string tensor.
    shard: Integer.  The shard for the filename.
    num_shards: An int Tensor for the number of shards.

  Returns:
    A string tensor.
  """
  ...

def registered_saver_filename(filename_tensor: tensor_lib.Tensor, saver_name: registration.RegisteredSaver) -> tensor_lib.Tensor:
  ...

_restore_noop = ...
TensorKeyAndSliceSpec = tuple[str, str]
RestoreFn = Callable[[Mapping[str, tensor_lib.Tensor]], ops.Operation]
class MultiDeviceSaver:
  """Saves checkpoints directly from multiple devices.

  Note that this is a low-level utility which stores Tensors in the keys
  specified by `SaveableObject`s. Higher-level utilities for object-based
  checkpointing are built on top of it.
  """
  def __init__(self, serialized_tensors: Mapping[base.Trackable, sharding_util.Shard], registered_savers: RegisteredSaversDict | None = ..., call_with_mapped_captures: MappedCapturesCallable | None = ...) -> None:
    """Specify a list of `SaveableObject`s to save and restore.

    Args:
      serialized_tensors: A dictionary mapping `Trackable` to a tensor dict,
        which maps checkpoint_key -> (slice_spec ->) -> Tensor/SaveSpec. The
        `Trackable` key is used to get the `restore_from_tensors` function,
        and may be `None` if the tensor is not meant to be restored.
      registered_savers: A dictionary mapping `registration.RegisteredSaver`
        namedtuples to a dictionary of named Trackables. The keys of the
        Trackable dictionary are string names that uniquely identify the
        Trackable in the checkpoint.
      call_with_mapped_captures: TODO
    """
    ...
  
  @classmethod
  def from_saveables(cls, saveables: Sequence[base.Trackable], registered_savers: RegisteredSaversDict | None = ..., call_with_mapped_captures: MappedCapturesCallable | None = ...) -> MultiDeviceSaver:
    """Constructs a MultiDeviceSaver from a list of `SaveableObject`s."""
    ...
  
  def to_proto(self) -> saver_pb2.SaverDef:
    """Serializes to a SaverDef referencing the current graph."""
    ...
  
  def save(self, file_prefix: tensor_lib.Tensor, options: checkpoint_options.CheckpointOptions | None = ...) -> ops.Operation:
    """Save the saveable objects to a checkpoint with `file_prefix`.

    Args:
      file_prefix: A string or scalar string Tensor containing the prefix to
        save under.
      options: Optional `CheckpointOptions` object.
    Returns:
      An `Operation`, or None when executing eagerly.
    """
    ...
  
  def restore(self, file_prefix: tensor_lib.Tensor, options: checkpoint_options.CheckpointOptions | None = ...) -> Mapping[str, ops.Operation]:
    """Restore the saveable objects from a checkpoint with `file_prefix`.

    Args:
      file_prefix: A string or scalar string Tensor containing the prefix for
        files to read from.
      options: Optional `CheckpointOptions` object.

    Returns:
      When not run eagerly or when saving on a single device, returns a
      dictionary mapping from SaveableObject names to restore operations;
      otherwise, returns an empty dict.
    """
    ...
  


