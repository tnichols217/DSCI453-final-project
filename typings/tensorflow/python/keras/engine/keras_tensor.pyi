"""
This type stub file was generated by pyright.
"""

from tensorflow.python.framework import tensor_shape, type_spec as type_spec_module

"""Keras Input Tensor used to track functional API Topology."""
_MAX_TENSOR_RANK = ...
class KerasTensor:
  """A representation of a Keras in/output during Functional API construction.

  `KerasTensor`s are tensor-like objects that represent the symbolic inputs
  and outputs of Keras layers during Functional model construction. They are
  comprised of the `tf.TypeSpec` of the (Composite)Tensor that will be
  consumed/produced in the corresponding location of the Functional model.

  KerasTensors are intended as a private API, so users should never need to
  directly instantiate `KerasTensor`s.

  **Building Functional Models with KerasTensors**
  `tf.keras.Input` produces `KerasTensor`s that represent the symbolic inputs
  to your model.

  Passing a `KerasTensor` to a `tf.keras.Layer` `__call__` lets the layer know
  that you are building a Functional model. The layer __call__ will
  infer the output signature and return `KerasTensor`s with `tf.TypeSpec`s
  corresponding to the symbolic outputs of that layer call. These output
  `KerasTensor`s will have all of the internal KerasHistory metadata attached
  to them that Keras needs to construct a Functional Model.

  Currently, layers infer the output signature by:
    * creating a scratch `FuncGraph`
    * making placeholders in the scratch graph that match the input typespecs
    * Calling `layer.call` on these placeholders
    * extracting the signatures of the outputs before clearing the scratch graph

  (Note: names assigned to KerasTensors by this process are not guaranteed to
  be unique, and are subject to implementation details).

  `tf.nest` methods are used to insure all of the inputs/output data
  structures get maintained, with elements swapped between KerasTensors and
  placeholders.

  In rare cases (such as when directly manipulating shapes using Keras layers),
  the layer may be able to partially infer the value of the output in addition
  to just inferring the signature.
  When this happens, the returned KerasTensor will also contain the inferred
  value information. Follow-on layers can use this information.
  during their own output signature inference.
  E.g. if one layer produces a symbolic `KerasTensor` that the next layer uses
  as the shape of its outputs, partially knowing the value helps infer the
  output shape.

  **Automatically converting TF APIs to layers**:
  If you passing a `KerasTensor` to a TF API that supports dispatching,
  Keras will automatically turn that API call into a lambda
  layer in the Functional model, and return KerasTensors representing the
  symbolic outputs.

  Most TF APIs that take only tensors as input and produce output tensors
  will support dispatching.

  Calling a `tf.function` does not support dispatching, so you cannot pass
  `KerasTensor`s as inputs to a `tf.function`.

  Higher-order APIs that take methods which produce tensors (e.g. `tf.while`,
  `tf.map_fn`, `tf.cond`) also do not currently support dispatching. So, you
  cannot directly pass KerasTensors as inputs to these APIs either. If you
  want to use these APIs inside of a Functional model, you must put them inside
  of a custom layer.

  Args:
    type_spec: The `tf.TypeSpec` for the symbolic input created by
      `tf.keras.Input`, or symbolically inferred for the output
      during a symbolic layer `__call__`.
    inferred_value: (Optional) a non-symbolic static value, possibly partially
      specified, that could be symbolically inferred for the outputs during
      a symbolic layer `__call__`. This will generally only happen when
      grabbing and manipulating `tf.int32` shapes directly as tensors.
      Statically inferring values in this way and storing them in the
      KerasTensor allows follow-on layers to infer output signatures
      more effectively. (e.g. when using a symbolic shape tensor to later
      construct a tensor with that shape).
    name: (optional) string name for this KerasTensor. Names automatically
      generated by symbolic layer `__call__`s are not guaranteed to be unique,
      and are subject to implementation details.
  """
  def __init__(self, type_spec, inferred_value=..., name=...) -> None:
    """Constructs a KerasTensor."""
    ...
  
  @property
  def type_spec(self): # -> TypeSpec:
    """Returns the `tf.TypeSpec` symbolically inferred for this Keras output."""
    ...
  
  @property
  def shape(self):
    """Returns the `TensorShape` symbolically inferred for this Keras output."""
    ...
  
  @classmethod
  def from_tensor(cls, tensor): # -> KerasTensor | Self:
    """Convert a traced (composite)tensor to a representative KerasTensor."""
    ...
  
  @classmethod
  def from_type_spec(cls, type_spec, name=...): # -> Self:
    ...
  
  def get_shape(self) -> tensor_shape.TensorShape:
    ...
  
  def __len__(self):
    ...
  
  @property
  def op(self):
    ...
  
  def __hash__(self) -> int:
    ...
  
  __array_priority__ = ...
  def __array__(self):
    ...
  
  @property
  def is_tensor_like(self): # -> Literal[True]:
    ...
  
  def set_shape(self, shape): # -> None:
    """Updates the shape of this KerasTensor. Mimics `tf.Tensor.set_shape()`."""
    ...
  
  def __str__(self) -> str:
    ...
  
  def __repr__(self): # -> str:
    ...
  
  @property
  def dtype(self):
    """Returns the `dtype` symbolically inferred for this Keras output."""
    ...
  
  def ref(self): # -> Reference:
    """Returns a hashable reference object to this KerasTensor.

    The primary use case for this API is to put KerasTensors in a
    set/dictionary. We can't put tensors in a set/dictionary as
    `tensor.__hash__()` is not available and tensor equality (`==`) is supposed
    to produce a tensor representing if the two inputs are equal.

    See the documentation of `tf.Tensor.ref()` for more info.
    """
    ...
  
  def __iter__(self): # -> _KerasTensorIterator:
    ...
  
  @property
  def name(self): # -> None:
    """Returns the (non-unique, optional) name of this symbolic Keras value."""
    ...
  


class SparseKerasTensor(KerasTensor):
  """A specialized KerasTensor representation for `tf.sparse.SparseTensor`s.

  Specifically, it specializes the conversion to a placeholder in order
  to maintain dense shape information.
  """
  ...


class RaggedKerasTensor(KerasTensor):
  """A specialized KerasTensor representation for `tf.RaggedTensor`s.

  Specifically, it:

  1. Specializes the conversion to a placeholder in order
  to maintain shape information for non-ragged dimensions.
  2. Overloads the KerasTensor's operators with the RaggedTensor versions
  when they don't match the `tf.Tensor` versions
  3. Exposes some of the instance method/attribute that are unique to
  the RaggedTensor API (such as ragged_rank).
  """
  @property
  def ragged_rank(self):
    ...
  


class UserRegisteredSpec(type_spec_module.TypeSpec):
  """TypeSpec to represent user-registered symbolic objects."""
  def __init__(self, shape, dtype) -> None:
    ...
  
  def value_type(self):
    ...
  


class UserRegisteredTypeKerasTensor(KerasTensor):
  """KerasTensor that represents legacy register_symbolic_tensor_type."""
  def __init__(self, user_registered_symbolic_object) -> None:
    ...
  
  @classmethod
  def from_tensor(cls, tensor): # -> Self:
    ...
  
  @classmethod
  def from_type_spec(cls, type_spec, name=...):
    ...
  


class _KerasTensorIterator:
  """Iterates over the leading dim of a KerasTensor. Performs 0 error checks."""
  def __init__(self, tensor, dim0) -> None:
    ...
  
  def __iter__(self): # -> Self:
    ...
  
  def __next__(self):
    ...
  


keras_tensor_classes = ...
def register_keras_tensor_specialization(cls, keras_tensor_subclass): # -> None:
  """Register a specialized KerasTensor subclass for a Tensor type."""
  ...

def keras_tensor_to_placeholder(x): # -> Any | Operation | _EagerTensorBase | defaultdict[Any, Any] | list[Any] | object | None:
  """Construct a graph placeholder to represent a KerasTensor when tracing."""
  ...

def keras_tensor_from_tensor(tensor):
  """Convert a traced (composite)tensor to a representative KerasTensor."""
  ...

def keras_tensor_from_type_spec(type_spec, name=...):
  """Convert a TypeSpec to a representative KerasTensor."""
  ...

