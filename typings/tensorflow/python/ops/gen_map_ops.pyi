"""
This type stub file was generated by pyright.
"""

from tensorflow.security.fuzzing.py import annotation_types as _atypes
from typing import Any, TypeVar
from typing_extensions import Annotated

"""Python wrappers around TensorFlow ops.

This file is MACHINE GENERATED! Do not edit.
"""
def empty_tensor_map(name=...) -> Annotated[Any, _atypes.Variant]:
  r"""Creates and returns an empty tensor map.

  handle: an empty tensor map

  Args:
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
  ...

EmptyTensorMap = ...
def empty_tensor_map_eager_fallback(name, ctx) -> Annotated[Any, _atypes.Variant]:
  ...

TV_TensorMapErase_key_dtype = TypeVar("TV_TensorMapErase_key_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
TV_TensorMapErase_value_dtype = TypeVar("TV_TensorMapErase_value_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def tensor_map_erase(input_handle: Annotated[Any, _atypes.Variant], key: Annotated[Any, TV_TensorMapErase_key_dtype], value_dtype: TV_TensorMapErase_value_dtype, name=...) -> Annotated[Any, _atypes.Variant]:
  r"""Returns a tensor map with item from given key erased.

  input_handle: the original map
  output_handle: the map with value from given key removed
  key: the key of the value to be erased

  Args:
    input_handle: A `Tensor` of type `variant`.
    key: A `Tensor`.
    value_dtype: A `tf.DType`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
  ...

TensorMapErase = ...
def tensor_map_erase_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], key: Annotated[Any, TV_TensorMapErase_key_dtype], value_dtype: TV_TensorMapErase_value_dtype, name, ctx) -> Annotated[Any, _atypes.Variant]:
  ...

TV_TensorMapHasKey_key_dtype = TypeVar("TV_TensorMapHasKey_key_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def tensor_map_has_key(input_handle: Annotated[Any, _atypes.Variant], key: Annotated[Any, TV_TensorMapHasKey_key_dtype], name=...) -> Annotated[Any, _atypes.Bool]:
  r"""Returns whether the given key exists in the map.

  input_handle: the input map
  key: the key to check
  has_key: whether the key is already in the map or not

  Args:
    input_handle: A `Tensor` of type `variant`.
    key: A `Tensor`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `bool`.
  """
  ...

TensorMapHasKey = ...
def tensor_map_has_key_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], key: Annotated[Any, TV_TensorMapHasKey_key_dtype], name, ctx) -> Annotated[Any, _atypes.Bool]:
  ...

TV_TensorMapInsert_key_dtype = TypeVar("TV_TensorMapInsert_key_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
TV_TensorMapInsert_value_dtype = TypeVar("TV_TensorMapInsert_value_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def tensor_map_insert(input_handle: Annotated[Any, _atypes.Variant], key: Annotated[Any, TV_TensorMapInsert_key_dtype], value: Annotated[Any, TV_TensorMapInsert_value_dtype], name=...) -> Annotated[Any, _atypes.Variant]:
  r"""Returns a map that is the 'input_handle' with the given key-value pair inserted.

  input_handle: the original map
  output_handle: the map with key and value inserted
  key: the key to be inserted
  value: the value to be inserted

  Args:
    input_handle: A `Tensor` of type `variant`.
    key: A `Tensor`.
    value: A `Tensor`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
  ...

TensorMapInsert = ...
def tensor_map_insert_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], key: Annotated[Any, TV_TensorMapInsert_key_dtype], value: Annotated[Any, TV_TensorMapInsert_value_dtype], name, ctx) -> Annotated[Any, _atypes.Variant]:
  ...

TV_TensorMapLookup_key_dtype = TypeVar("TV_TensorMapLookup_key_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
TV_TensorMapLookup_value_dtype = TypeVar("TV_TensorMapLookup_value_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def tensor_map_lookup(input_handle: Annotated[Any, _atypes.Variant], key: Annotated[Any, TV_TensorMapLookup_key_dtype], value_dtype: TV_TensorMapLookup_value_dtype, name=...) -> Annotated[Any, TV_TensorMapLookup_value_dtype]:
  r"""Returns the value from a given key in a tensor map.

  input_handle: the input map
  key: the key to be looked up
  value: the value found from the given key

  Args:
    input_handle: A `Tensor` of type `variant`.
    key: A `Tensor`.
    value_dtype: A `tf.DType`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `value_dtype`.
  """
  ...

TensorMapLookup = ...
def tensor_map_lookup_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], key: Annotated[Any, TV_TensorMapLookup_key_dtype], value_dtype: TV_TensorMapLookup_value_dtype, name, ctx) -> Annotated[Any, TV_TensorMapLookup_value_dtype]:
  ...

def tensor_map_size(input_handle: Annotated[Any, _atypes.Variant], name=...) -> Annotated[Any, _atypes.Int32]:
  r"""Returns the number of tensors in the input tensor map.

  input_handle: the input map
  size: the number of tensors in the map

  Args:
    input_handle: A `Tensor` of type `variant`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `int32`.
  """
  ...

TensorMapSize = ...
def tensor_map_size_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], name, ctx) -> Annotated[Any, _atypes.Int32]:
  ...

TV_TensorMapStackKeys_key_dtype = TypeVar("TV_TensorMapStackKeys_key_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def tensor_map_stack_keys(input_handle: Annotated[Any, _atypes.Variant], key_dtype: TV_TensorMapStackKeys_key_dtype, name=...) -> Annotated[Any, TV_TensorMapStackKeys_key_dtype]:
  r"""Returns a Tensor stack of all keys in a tensor map.

  input_handle: the input map
  keys: the returned Tensor of all keys in the map

  Args:
    input_handle: A `Tensor` of type `variant`.
    key_dtype: A `tf.DType`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `key_dtype`.
  """
  ...

TensorMapStackKeys = ...
def tensor_map_stack_keys_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], key_dtype: TV_TensorMapStackKeys_key_dtype, name, ctx) -> Annotated[Any, TV_TensorMapStackKeys_key_dtype]:
  ...

