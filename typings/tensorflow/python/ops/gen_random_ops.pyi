"""
This type stub file was generated by pyright.
"""

from tensorflow.security.fuzzing.py import annotation_types as _atypes
from typing import Any, TypeVar
from typing_extensions import Annotated

"""Python wrappers around TensorFlow ops.

This file is MACHINE GENERATED! Do not edit.
"""
TV_Multinomial_T = TypeVar("TV_Multinomial_T", _atypes.BFloat16, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_Multinomial_output_dtype = TypeVar("TV_Multinomial_output_dtype", _atypes.Int32, _atypes.Int64)
def multinomial(logits: Annotated[Any, TV_Multinomial_T], num_samples: Annotated[Any, _atypes.Int32], seed: int = ..., seed2: int = ..., output_dtype: TV_Multinomial_output_dtype = ..., name=...) -> Annotated[Any, TV_Multinomial_output_dtype]:
  r"""Draws samples from a multinomial distribution.

  Args:
    logits: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `int64`, `bfloat16`, `uint16`, `half`, `uint32`, `uint64`.
      2-D Tensor with shape `[batch_size, num_classes]`.  Each slice `[i, :]`
      represents the unnormalized log probabilities for all classes.
    num_samples: A `Tensor` of type `int32`.
      0-D.  Number of independent samples to draw for each row slice.
    seed: An optional `int`. Defaults to `0`.
      If either seed or seed2 is set to be non-zero, the internal random number
      generator is seeded by the given seed.  Otherwise, a random seed is used.
    seed2: An optional `int`. Defaults to `0`.
      A second seed to avoid seed collision.
    output_dtype: An optional `tf.DType` from: `tf.int32, tf.int64`. Defaults to `tf.int64`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `output_dtype`.
  """
  ...

Multinomial = ...
def multinomial_eager_fallback(logits: Annotated[Any, TV_Multinomial_T], num_samples: Annotated[Any, _atypes.Int32], seed: int, seed2: int, output_dtype: TV_Multinomial_output_dtype, name, ctx) -> Annotated[Any, TV_Multinomial_output_dtype]:
  ...

TV_ParameterizedTruncatedNormal_dtype = TypeVar("TV_ParameterizedTruncatedNormal_dtype", _atypes.BFloat16, _atypes.Float32, _atypes.Float64, _atypes.Half)
TV_ParameterizedTruncatedNormal_T = TypeVar("TV_ParameterizedTruncatedNormal_T", _atypes.Int32, _atypes.Int64)
def parameterized_truncated_normal(shape: Annotated[Any, TV_ParameterizedTruncatedNormal_T], means: Annotated[Any, TV_ParameterizedTruncatedNormal_dtype], stdevs: Annotated[Any, TV_ParameterizedTruncatedNormal_dtype], minvals: Annotated[Any, TV_ParameterizedTruncatedNormal_dtype], maxvals: Annotated[Any, TV_ParameterizedTruncatedNormal_dtype], seed: int = ..., seed2: int = ..., name=...) -> Annotated[Any, TV_ParameterizedTruncatedNormal_dtype]:
  r"""Outputs random values from a normal distribution. The parameters may each be a

  scalar which applies to the entire output, or a vector of length shape[0] which
  stores the parameters for each batch.

  Args:
    shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      The shape of the output tensor. Batches are indexed by the 0th dimension.
    means: A `Tensor`. Must be one of the following types: `half`, `bfloat16`, `float32`, `float64`.
      The mean parameter of each batch.
    stdevs: A `Tensor`. Must have the same type as `means`.
      The standard deviation parameter of each batch. Must be greater than 0.
    minvals: A `Tensor`. Must have the same type as `means`.
      The minimum cutoff. May be -infinity.
    maxvals: A `Tensor`. Must have the same type as `means`.
      The maximum cutoff. May be +infinity, and must be more than the minval
      for each batch.
    seed: An optional `int`. Defaults to `0`.
      If either `seed` or `seed2` are set to be non-zero, the random number
      generator is seeded by the given seed.  Otherwise, it is seeded by a
      random seed.
    seed2: An optional `int`. Defaults to `0`.
      A second seed to avoid seed collision.
    name: A name for the operation (optional).

  Returns:
    A `Tensor`. Has the same type as `means`.
  """
  ...

ParameterizedTruncatedNormal = ...
def parameterized_truncated_normal_eager_fallback(shape: Annotated[Any, TV_ParameterizedTruncatedNormal_T], means: Annotated[Any, TV_ParameterizedTruncatedNormal_dtype], stdevs: Annotated[Any, TV_ParameterizedTruncatedNormal_dtype], minvals: Annotated[Any, TV_ParameterizedTruncatedNormal_dtype], maxvals: Annotated[Any, TV_ParameterizedTruncatedNormal_dtype], seed: int, seed2: int, name, ctx) -> Annotated[Any, TV_ParameterizedTruncatedNormal_dtype]:
  ...

TV_RandomGamma_S = TypeVar("TV_RandomGamma_S", _atypes.Int32, _atypes.Int64)
TV_RandomGamma_T = TypeVar("TV_RandomGamma_T", _atypes.Float32, _atypes.Float64, _atypes.Half)
def random_gamma(shape: Annotated[Any, TV_RandomGamma_S], alpha: Annotated[Any, TV_RandomGamma_T], seed: int = ..., seed2: int = ..., name=...) -> Annotated[Any, TV_RandomGamma_T]:
  r"""Outputs random values from the Gamma distribution(s) described by alpha.

  This op uses the algorithm by Marsaglia et al. to acquire samples via
  transformation-rejection from pairs of uniform and normal random variables.
  See http://dl.acm.org/citation.cfm?id=358414

  Args:
    shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      1-D integer tensor. Shape of independent samples to draw from each
      distribution described by the shape parameters given in alpha.
    alpha: A `Tensor`. Must be one of the following types: `half`, `float32`, `float64`.
      A tensor in which each scalar is a "shape" parameter describing the
      associated gamma distribution.
    seed: An optional `int`. Defaults to `0`.
      If either `seed` or `seed2` are set to be non-zero, the random number
      generator is seeded by the given seed.  Otherwise, it is seeded by a
      random seed.
    seed2: An optional `int`. Defaults to `0`.
      A second seed to avoid seed collision.
    name: A name for the operation (optional).

  Returns:
    A `Tensor`. Has the same type as `alpha`.
  """
  ...

RandomGamma = ...
def random_gamma_eager_fallback(shape: Annotated[Any, TV_RandomGamma_S], alpha: Annotated[Any, TV_RandomGamma_T], seed: int, seed2: int, name, ctx) -> Annotated[Any, TV_RandomGamma_T]:
  ...

TV_RandomGammaGrad_T = TypeVar("TV_RandomGammaGrad_T", _atypes.Float32, _atypes.Float64)
def random_gamma_grad(alpha: Annotated[Any, TV_RandomGammaGrad_T], sample: Annotated[Any, TV_RandomGammaGrad_T], name=...) -> Annotated[Any, TV_RandomGammaGrad_T]:
  r"""Computes the derivative of a Gamma random sample w.r.t. `alpha`.

  Args:
    alpha: A `Tensor`. Must be one of the following types: `float32`, `float64`.
    sample: A `Tensor`. Must have the same type as `alpha`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor`. Has the same type as `alpha`.
  """
  ...

RandomGammaGrad = ...
def random_gamma_grad_eager_fallback(alpha: Annotated[Any, TV_RandomGammaGrad_T], sample: Annotated[Any, TV_RandomGammaGrad_T], name, ctx) -> Annotated[Any, TV_RandomGammaGrad_T]:
  ...

TV_RandomPoisson_S = TypeVar("TV_RandomPoisson_S", _atypes.Int32, _atypes.Int64)
TV_RandomPoisson_dtype = TypeVar("TV_RandomPoisson_dtype", _atypes.Float32, _atypes.Float64, _atypes.Half)
def random_poisson(shape: Annotated[Any, TV_RandomPoisson_S], rate: Annotated[Any, TV_RandomPoisson_dtype], seed: int = ..., seed2: int = ..., name=...) -> Annotated[Any, TV_RandomPoisson_dtype]:
  r"""Use RandomPoissonV2 instead.

  Args:
    shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.
    rate: A `Tensor`. Must be one of the following types: `half`, `float32`, `float64`.
    seed: An optional `int`. Defaults to `0`.
    seed2: An optional `int`. Defaults to `0`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor`. Has the same type as `rate`.
  """
  ...

RandomPoisson = ...
def random_poisson_eager_fallback(shape: Annotated[Any, TV_RandomPoisson_S], rate: Annotated[Any, TV_RandomPoisson_dtype], seed: int, seed2: int, name, ctx) -> Annotated[Any, TV_RandomPoisson_dtype]:
  ...

TV_RandomPoissonV2_S = TypeVar("TV_RandomPoissonV2_S", _atypes.Int32, _atypes.Int64)
TV_RandomPoissonV2_R = TypeVar("TV_RandomPoissonV2_R", _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int32, _atypes.Int64)
TV_RandomPoissonV2_dtype = TypeVar("TV_RandomPoissonV2_dtype", _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int32, _atypes.Int64)
def random_poisson_v2(shape: Annotated[Any, TV_RandomPoissonV2_S], rate: Annotated[Any, TV_RandomPoissonV2_R], seed: int = ..., seed2: int = ..., dtype: TV_RandomPoissonV2_dtype = ..., name=...) -> Annotated[Any, TV_RandomPoissonV2_dtype]:
  r"""Outputs random values from the Poisson distribution(s) described by rate.

  This op uses two algorithms, depending on rate. If rate >= 10, then
  the algorithm by Hormann is used to acquire samples via
  transformation-rejection.
  See http://www.sciencedirect.com/science/article/pii/0167668793909974.

  Otherwise, Knuth's algorithm is used to acquire samples via multiplying uniform
  random variables.
  See Donald E. Knuth (1969). Seminumerical Algorithms. The Art of Computer
  Programming, Volume 2. Addison Wesley

  Args:
    shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      1-D integer tensor. Shape of independent samples to draw from each
      distribution described by the shape parameters given in rate.
    rate: A `Tensor`. Must be one of the following types: `half`, `float32`, `float64`, `int32`, `int64`.
      A tensor in which each scalar is a "rate" parameter describing the
      associated poisson distribution.
    seed: An optional `int`. Defaults to `0`.
      If either `seed` or `seed2` are set to be non-zero, the random number
      generator is seeded by the given seed.  Otherwise, it is seeded by a
      random seed.
    seed2: An optional `int`. Defaults to `0`.
      A second seed to avoid seed collision.
    dtype: An optional `tf.DType` from: `tf.half, tf.float32, tf.float64, tf.int32, tf.int64`. Defaults to `tf.int64`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `dtype`.
  """
  ...

RandomPoissonV2 = ...
def random_poisson_v2_eager_fallback(shape: Annotated[Any, TV_RandomPoissonV2_S], rate: Annotated[Any, TV_RandomPoissonV2_R], seed: int, seed2: int, dtype: TV_RandomPoissonV2_dtype, name, ctx) -> Annotated[Any, TV_RandomPoissonV2_dtype]:
  ...

TV_RandomShuffle_T = TypeVar("TV_RandomShuffle_T", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def random_shuffle(value: Annotated[Any, TV_RandomShuffle_T], seed: int = ..., seed2: int = ..., name=...) -> Annotated[Any, TV_RandomShuffle_T]:
  r"""Randomly shuffles a tensor along its first dimension.

    The tensor is shuffled along dimension 0, such that each `value[j]` is mapped
    to one and only one `output[i]`. For example, a mapping that might occur for a
    3x2 tensor is:

  ```
  [[1, 2],       [[5, 6],
   [3, 4],  ==>   [1, 2],
   [5, 6]]        [3, 4]]
  ```

  Args:
    value: A `Tensor`. The tensor to be shuffled.
    seed: An optional `int`. Defaults to `0`.
      If either `seed` or `seed2` are set to be non-zero, the random number
      generator is seeded by the given seed.  Otherwise, it is seeded by a
      random seed.
    seed2: An optional `int`. Defaults to `0`.
      A second seed to avoid seed collision.
    name: A name for the operation (optional).

  Returns:
    A `Tensor`. Has the same type as `value`.
  """
  ...

RandomShuffle = ...
def random_shuffle_eager_fallback(value: Annotated[Any, TV_RandomShuffle_T], seed: int, seed2: int, name, ctx) -> Annotated[Any, TV_RandomShuffle_T]:
  ...

TV_RandomStandardNormal_dtype = TypeVar("TV_RandomStandardNormal_dtype", _atypes.BFloat16, _atypes.Float32, _atypes.Float64, _atypes.Half)
TV_RandomStandardNormal_T = TypeVar("TV_RandomStandardNormal_T", _atypes.Int32, _atypes.Int64)
def random_standard_normal(shape: Annotated[Any, TV_RandomStandardNormal_T], dtype: TV_RandomStandardNormal_dtype, seed: int = ..., seed2: int = ..., name=...) -> Annotated[Any, TV_RandomStandardNormal_dtype]:
  r"""Outputs random values from a normal distribution.

  The generated values will have mean 0 and standard deviation 1.

  Args:
    shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      The shape of the output tensor.
    dtype: A `tf.DType` from: `tf.half, tf.bfloat16, tf.float32, tf.float64`.
      The type of the output.
    seed: An optional `int`. Defaults to `0`.
      If either `seed` or `seed2` are set to be non-zero, the random number
      generator is seeded by the given seed.  Otherwise, it is seeded by a
      random seed.
    seed2: An optional `int`. Defaults to `0`.
      A second seed to avoid seed collision.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `dtype`.
  """
  ...

RandomStandardNormal = ...
def random_standard_normal_eager_fallback(shape: Annotated[Any, TV_RandomStandardNormal_T], dtype: TV_RandomStandardNormal_dtype, seed: int, seed2: int, name, ctx) -> Annotated[Any, TV_RandomStandardNormal_dtype]:
  ...

TV_RandomUniform_dtype = TypeVar("TV_RandomUniform_dtype", _atypes.BFloat16, _atypes.Float32, _atypes.Float64, _atypes.Half)
TV_RandomUniform_T = TypeVar("TV_RandomUniform_T", _atypes.Int32, _atypes.Int64)
def random_uniform(shape: Annotated[Any, TV_RandomUniform_T], dtype: TV_RandomUniform_dtype, seed: int = ..., seed2: int = ..., name=...) -> Annotated[Any, TV_RandomUniform_dtype]:
  r"""Outputs random values from a uniform distribution.

  The generated values follow a uniform distribution in the range `[0, 1)`. The
  lower bound 0 is included in the range, while the upper bound 1 is excluded.

  Args:
    shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      The shape of the output tensor.
    dtype: A `tf.DType` from: `tf.half, tf.bfloat16, tf.float32, tf.float64`.
      The type of the output.
    seed: An optional `int`. Defaults to `0`.
      If either `seed` or `seed2` are set to be non-zero, the random number
      generator is seeded by the given seed.  Otherwise, it is seeded by a
      random seed.
    seed2: An optional `int`. Defaults to `0`.
      A second seed to avoid seed collision.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `dtype`.
  """
  ...

RandomUniform = ...
def random_uniform_eager_fallback(shape: Annotated[Any, TV_RandomUniform_T], dtype: TV_RandomUniform_dtype, seed: int, seed2: int, name, ctx) -> Annotated[Any, TV_RandomUniform_dtype]:
  ...

TV_RandomUniformInt_Tout = TypeVar("TV_RandomUniformInt_Tout", _atypes.Int32, _atypes.Int64)
TV_RandomUniformInt_T = TypeVar("TV_RandomUniformInt_T", _atypes.Int32, _atypes.Int64)
def random_uniform_int(shape: Annotated[Any, TV_RandomUniformInt_T], minval: Annotated[Any, TV_RandomUniformInt_Tout], maxval: Annotated[Any, TV_RandomUniformInt_Tout], seed: int = ..., seed2: int = ..., name=...) -> Annotated[Any, TV_RandomUniformInt_Tout]:
  r"""Outputs random integers from a uniform distribution.

  The generated values are uniform integers in the range `[minval, maxval)`.
  The lower bound `minval` is included in the range, while the upper bound
  `maxval` is excluded.

  The random integers are slightly biased unless `maxval - minval` is an exact
  power of two.  The bias is small for values of `maxval - minval` significantly
  smaller than the range of the output (either `2^32` or `2^64`).

  Args:
    shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      The shape of the output tensor.
    minval: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      0-D.  Inclusive lower bound on the generated integers.
    maxval: A `Tensor`. Must have the same type as `minval`.
      0-D.  Exclusive upper bound on the generated integers.
    seed: An optional `int`. Defaults to `0`.
      If either `seed` or `seed2` are set to be non-zero, the random number
      generator is seeded by the given seed.  Otherwise, it is seeded by a
      random seed.
    seed2: An optional `int`. Defaults to `0`.
      A second seed to avoid seed collision.
    name: A name for the operation (optional).

  Returns:
    A `Tensor`. Has the same type as `minval`.
  """
  ...

RandomUniformInt = ...
def random_uniform_int_eager_fallback(shape: Annotated[Any, TV_RandomUniformInt_T], minval: Annotated[Any, TV_RandomUniformInt_Tout], maxval: Annotated[Any, TV_RandomUniformInt_Tout], seed: int, seed2: int, name, ctx) -> Annotated[Any, TV_RandomUniformInt_Tout]:
  ...

TV_TruncatedNormal_dtype = TypeVar("TV_TruncatedNormal_dtype", _atypes.BFloat16, _atypes.Float32, _atypes.Float64, _atypes.Half)
TV_TruncatedNormal_T = TypeVar("TV_TruncatedNormal_T", _atypes.Int32, _atypes.Int64)
def truncated_normal(shape: Annotated[Any, TV_TruncatedNormal_T], dtype: TV_TruncatedNormal_dtype, seed: int = ..., seed2: int = ..., name=...) -> Annotated[Any, TV_TruncatedNormal_dtype]:
  r"""Outputs random values from a truncated normal distribution.

  The generated values follow a normal distribution with mean 0 and standard
  deviation 1, except that values whose magnitude is more than 2 standard
  deviations from the mean are dropped and re-picked.

  Args:
    shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      The shape of the output tensor.
    dtype: A `tf.DType` from: `tf.half, tf.bfloat16, tf.float32, tf.float64`.
      The type of the output.
    seed: An optional `int`. Defaults to `0`.
      If either `seed` or `seed2` are set to be non-zero, the random number
      generator is seeded by the given seed.  Otherwise, it is seeded by a
      random seed.
    seed2: An optional `int`. Defaults to `0`.
      A second seed to avoid seed collision.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `dtype`.
  """
  ...

TruncatedNormal = ...
def truncated_normal_eager_fallback(shape: Annotated[Any, TV_TruncatedNormal_T], dtype: TV_TruncatedNormal_dtype, seed: int, seed2: int, name, ctx) -> Annotated[Any, TV_TruncatedNormal_dtype]:
  ...

