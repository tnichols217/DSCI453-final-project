"""
This type stub file was generated by pyright.
"""

import abc
import collections
from tensorflow.python.ops.linalg.sparse import gen_sparse_csr_matrix_ops as sm_ops
from tensorflow.python.ops.linalg.sparse.gen_sparse_csr_matrix_ops import *

"""CSR Sparse Matrix Operations."""
__all__ = ["SparseMatrix", "CSRSparseMatrix", "matmul", "dense_shape_and_type"]
__all__ += [_x for _x in dir(sm_ops) if not _x.startswith("_")]
class DenseShapeAndType(collections.namedtuple("DenseShapeAndType", ("shape", "dtype"))):
  ...


def get_shape_and_type(matrix): # -> Any | None:
  """Return matrix's shape and type if available."""
  ...

def dense_shape_and_type(matrix): # -> DenseShapeAndType:
  """Get dense shape and dtype of the tf.Tensor containing the matrix.

  Args:
    matrix: A `tf.Tensor` of type `tf.variant` storing a sparse matrix.

  Returns:
    An instance of `ShapeAndType` with properties `shape` (a `tf.TensorShape`)
    and `dtype` (a `tf.DType`).

  Raises:
    TypeError: if `matrix` is not a tensor or its dtype is not variant.
    ValueError: if `matrix` lacks static handle data containing the dense
      shape and dtype.
  """
  ...

def matmul_shape_inference(a, b, c, transpose_a, transpose_b, adjoint_a, adjoint_b): # -> Any | None:
  """Helper function for matmul to set the result matrix's handle data."""
  ...

def matmul(a, b, transpose_a=..., transpose_b=..., adjoint_a=..., adjoint_b=..., name=...): # -> Any | None:
  """Perform a sparse matrix matmul between `a` and `b`.

  Performs a contraction between `a` and `b` along the two innermost dimensions.
  If both `a` and `b` are instances of `SparseMatrix`, returns a new instance
  of `SparseMatrix` (same type as `a`).  If one is not an instance of
  `SparseMatrix`, returns a dense `Tensor`:

  ```
  c = opA(a) . opB(b)
  ```
  where `opA` (resp. `opB`) is the transpose or hermitian transpose depending
  on the values of `transpose_a` (resp. `transpose_b`) and `adjoint_a`
  (resp. `adjoint_b`).

  Args:
    a: `Tensor` or `SparseMatrix`, having rank `2` or `3`.
    b: `Tensor` or `SparseMatrix`, having rank `2` or `3`.
    transpose_a: Python `bool`.
    transpose_b: Python `bool`.
    adjoint_a: Python `bool`.
    adjoint_b: Python `bool`.
    name: Optional name to use when creating ops.

  Returns:
    A `SparseMatrix` if both `a` and `b` are instances of `SparseMatrix`,
    otherwise a dense `Tensor`.
  """
  ...

class SparseMatrix(metaclass=abc.ABCMeta):
  """Abstract class for sparse matrix types."""
  @abc.abstractmethod
  def __init__(self) -> None:
    ...
  
  @abc.abstractmethod
  def to_dense(self): # -> None:
    ...
  
  @abc.abstractmethod
  def to_sparse_tensor(self): # -> None:
    ...
  
  @property
  def graph(self):
    ...
  
  @property
  def shape(self):
    ...
  
  @property
  def dtype(self):
    ...
  
  @property
  def eager_handle_data(self): # -> None:
    """Return the matrix's handle data iff in eager mode."""
    ...
  
  def conj(self): # -> None:
    ...
  
  def hermitian_transpose(self): # -> None:
    """Return the hermitian transpose of the matrix."""
    ...
  
  def nnz(self): # -> Any:
    """Number of stored values, including explicit zeros."""
    ...
  
  nonzero = ...
  def sorted_indices(self):
    ...
  
  def transpose(self): # -> None:
    ...
  


class CSRSparseMatrix(SparseMatrix):
  """(Optionally batched) CSR Sparse Matrix."""
  def __init__(self, value, indices=..., name=...) -> None:
    """Construct a CSRSparseMatrix from a dense matrix or SparseTensor.

    Args:
      value: A dense `2D` or `3D` Tensor or `SparseTensor`.
      indices: The nonzero indices of `value`
        (if `value` is not a `SparseTensor`).
      name: Optional op name.

    Raises:
      ValueError: if `value` is a `SparseTensor` and `indices` is not `None`.
    """
    ...
  
  def to_dense(self): # -> Any:
    ...
  
  def to_sparse_tensor(self): # -> SparseTensor:
    ...
  


