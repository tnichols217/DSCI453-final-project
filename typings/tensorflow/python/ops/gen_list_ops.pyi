"""
This type stub file was generated by pyright.
"""

from tensorflow.security.fuzzing.py import annotation_types as _atypes
from typing import Any, TypeVar
from typing_extensions import Annotated

"""Python wrappers around TensorFlow ops.

This file is MACHINE GENERATED! Do not edit.
"""
TV_EmptyTensorList_element_dtype = TypeVar("TV_EmptyTensorList_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
TV_EmptyTensorList_shape_type = TypeVar("TV_EmptyTensorList_shape_type", _atypes.Int32, _atypes.Int64)
def empty_tensor_list(element_shape: Annotated[Any, TV_EmptyTensorList_shape_type], max_num_elements: Annotated[Any, _atypes.Int32], element_dtype: TV_EmptyTensorList_element_dtype, name=...) -> Annotated[Any, _atypes.Variant]:
  r"""Creates and returns an empty tensor list.

  All list elements must be tensors of dtype element_dtype and shape compatible
  with element_shape.

  handle: an empty tensor list.
  element_dtype: the type of elements in the list.
  element_shape: a shape compatible with that of elements in the list.

  Args:
    element_shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.
    max_num_elements: A `Tensor` of type `int32`.
    element_dtype: A `tf.DType`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
  ...

EmptyTensorList = ...
def empty_tensor_list_eager_fallback(element_shape: Annotated[Any, TV_EmptyTensorList_shape_type], max_num_elements: Annotated[Any, _atypes.Int32], element_dtype: TV_EmptyTensorList_element_dtype, name, ctx) -> Annotated[Any, _atypes.Variant]:
  ...

_TensorListConcatOutput = ...
TV_TensorListConcat_element_dtype = TypeVar("TV_TensorListConcat_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def tensor_list_concat(input_handle: Annotated[Any, _atypes.Variant], element_dtype: TV_TensorListConcat_element_dtype, element_shape=..., name=...): # -> TensorListConcat:
  r"""Concats all tensors in the list along the 0th dimension.

  Requires that all tensors have the same shape except the first dimension.

  input_handle: The input list.
  tensor: The concated result.
  lengths: Output tensor containing sizes of the 0th dimension of tensors in the list, used for computing the gradient.

  Args:
    input_handle: A `Tensor` of type `variant`.
    element_dtype: A `tf.DType`.
    element_shape: An optional `tf.TensorShape` or list of `ints`. Defaults to `None`.
    name: A name for the operation (optional).

  Returns:
    A tuple of `Tensor` objects (tensor, lengths).

    tensor: A `Tensor` of type `element_dtype`.
    lengths: A `Tensor` of type `int64`.
  """
  ...

TensorListConcat = ...
def tensor_list_concat_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], element_dtype: TV_TensorListConcat_element_dtype, element_shape, name, ctx): # -> TensorListConcat:
  ...

TV_TensorListConcatLists_element_dtype = TypeVar("TV_TensorListConcatLists_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def tensor_list_concat_lists(input_a: Annotated[Any, _atypes.Variant], input_b: Annotated[Any, _atypes.Variant], element_dtype: TV_TensorListConcatLists_element_dtype, name=...) -> Annotated[Any, _atypes.Variant]:
  r"""TODO: add doc.

  Args:
    input_a: A `Tensor` of type `variant`.
    input_b: A `Tensor` of type `variant`.
    element_dtype: A `tf.DType`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
  ...

TensorListConcatLists = ...
def tensor_list_concat_lists_eager_fallback(input_a: Annotated[Any, _atypes.Variant], input_b: Annotated[Any, _atypes.Variant], element_dtype: TV_TensorListConcatLists_element_dtype, name, ctx) -> Annotated[Any, _atypes.Variant]:
  ...

_TensorListConcatV2Output = ...
TV_TensorListConcatV2_element_dtype = TypeVar("TV_TensorListConcatV2_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
TV_TensorListConcatV2_shape_type = TypeVar("TV_TensorListConcatV2_shape_type", _atypes.Int32, _atypes.Int64)
def tensor_list_concat_v2(input_handle: Annotated[Any, _atypes.Variant], element_shape: Annotated[Any, TV_TensorListConcatV2_shape_type], leading_dims: Annotated[Any, _atypes.Int64], element_dtype: TV_TensorListConcatV2_element_dtype, name=...): # -> TensorListConcatV2:
  r"""Concats all tensors in the list along the 0th dimension.

  Requires that all tensors have the same shape except the first dimension.

  input_handle: The input list.
  element_shape: The shape of the uninitialized elements in the list. If the first
    dimension is not -1, it is assumed that all list elements have the same
    leading dim.
  leading_dims: The list of leading dims of uninitialized list elements. Used if
    the leading dim of input_handle.element_shape or the element_shape input arg
    is not already set.
  tensor: The concated result.
  lengths: Output tensor containing sizes of the 0th dimension of tensors in the list, used for computing the gradient.

  Args:
    input_handle: A `Tensor` of type `variant`.
    element_shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.
    leading_dims: A `Tensor` of type `int64`.
    element_dtype: A `tf.DType`.
    name: A name for the operation (optional).

  Returns:
    A tuple of `Tensor` objects (tensor, lengths).

    tensor: A `Tensor` of type `element_dtype`.
    lengths: A `Tensor` of type `int64`.
  """
  ...

TensorListConcatV2 = ...
def tensor_list_concat_v2_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], element_shape: Annotated[Any, TV_TensorListConcatV2_shape_type], leading_dims: Annotated[Any, _atypes.Int64], element_dtype: TV_TensorListConcatV2_element_dtype, name, ctx): # -> TensorListConcatV2:
  ...

TV_TensorListElementShape_shape_type = TypeVar("TV_TensorListElementShape_shape_type", _atypes.Int32, _atypes.Int64)
def tensor_list_element_shape(input_handle: Annotated[Any, _atypes.Variant], shape_type: TV_TensorListElementShape_shape_type, name=...) -> Annotated[Any, TV_TensorListElementShape_shape_type]:
  r"""The shape of the elements of the given list, as a tensor.

    input_handle: the list
    element_shape: the shape of elements of the list

  Args:
    input_handle: A `Tensor` of type `variant`.
    shape_type: A `tf.DType` from: `tf.int32, tf.int64`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `shape_type`.
  """
  ...

TensorListElementShape = ...
def tensor_list_element_shape_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], shape_type: TV_TensorListElementShape_shape_type, name, ctx) -> Annotated[Any, TV_TensorListElementShape_shape_type]:
  ...

TV_TensorListFromTensor_element_dtype = TypeVar("TV_TensorListFromTensor_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
TV_TensorListFromTensor_shape_type = TypeVar("TV_TensorListFromTensor_shape_type", _atypes.Int32, _atypes.Int64)
def tensor_list_from_tensor(tensor: Annotated[Any, TV_TensorListFromTensor_element_dtype], element_shape: Annotated[Any, TV_TensorListFromTensor_shape_type], name=...) -> Annotated[Any, _atypes.Variant]:
  r"""Creates a TensorList which, when stacked, has the value of `tensor`.

  Each tensor in the result list corresponds to one row of the input tensor.

  tensor: The input tensor.
  output_handle: The list.

  Args:
    tensor: A `Tensor`.
    element_shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
  ...

TensorListFromTensor = ...
def tensor_list_from_tensor_eager_fallback(tensor: Annotated[Any, TV_TensorListFromTensor_element_dtype], element_shape: Annotated[Any, TV_TensorListFromTensor_shape_type], name, ctx) -> Annotated[Any, _atypes.Variant]:
  ...

TV_TensorListGather_element_dtype = TypeVar("TV_TensorListGather_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def tensor_list_gather(input_handle: Annotated[Any, _atypes.Variant], indices: Annotated[Any, _atypes.Int32], element_shape: Annotated[Any, _atypes.Int32], element_dtype: TV_TensorListGather_element_dtype, name=...) -> Annotated[Any, TV_TensorListGather_element_dtype]:
  r"""Creates a Tensor by indexing into the TensorList.

  Each row in the produced Tensor corresponds to the element in the TensorList
  specified by the given index (see `tf.gather`).

  input_handle: The input tensor list.
  indices: The indices used to index into the list.
  values: The tensor.

  Args:
    input_handle: A `Tensor` of type `variant`.
    indices: A `Tensor` of type `int32`.
    element_shape: A `Tensor` of type `int32`.
    element_dtype: A `tf.DType`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `element_dtype`.
  """
  ...

TensorListGather = ...
def tensor_list_gather_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], indices: Annotated[Any, _atypes.Int32], element_shape: Annotated[Any, _atypes.Int32], element_dtype: TV_TensorListGather_element_dtype, name, ctx) -> Annotated[Any, TV_TensorListGather_element_dtype]:
  ...

TV_TensorListGetItem_element_dtype = TypeVar("TV_TensorListGetItem_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def tensor_list_get_item(input_handle: Annotated[Any, _atypes.Variant], index: Annotated[Any, _atypes.Int32], element_shape: Annotated[Any, _atypes.Int32], element_dtype: TV_TensorListGetItem_element_dtype, name=...) -> Annotated[Any, TV_TensorListGetItem_element_dtype]:
  r"""Returns the item in the list with the given index.

  input_handle: the list
  index: the position in the list from which an element will be retrieved
  item: the element at that position

  Args:
    input_handle: A `Tensor` of type `variant`.
    index: A `Tensor` of type `int32`.
    element_shape: A `Tensor` of type `int32`.
    element_dtype: A `tf.DType`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `element_dtype`.
  """
  ...

TensorListGetItem = ...
def tensor_list_get_item_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], index: Annotated[Any, _atypes.Int32], element_shape: Annotated[Any, _atypes.Int32], element_dtype: TV_TensorListGetItem_element_dtype, name, ctx) -> Annotated[Any, TV_TensorListGetItem_element_dtype]:
  ...

def tensor_list_length(input_handle: Annotated[Any, _atypes.Variant], name=...) -> Annotated[Any, _atypes.Int32]:
  r"""Returns the number of tensors in the input tensor list.

  input_handle: the input list
  length: the number of tensors in the list

  Args:
    input_handle: A `Tensor` of type `variant`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `int32`.
  """
  ...

TensorListLength = ...
def tensor_list_length_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], name, ctx) -> Annotated[Any, _atypes.Int32]:
  ...

_TensorListPopBackOutput = ...
TV_TensorListPopBack_element_dtype = TypeVar("TV_TensorListPopBack_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def tensor_list_pop_back(input_handle: Annotated[Any, _atypes.Variant], element_shape: Annotated[Any, _atypes.Int32], element_dtype: TV_TensorListPopBack_element_dtype, name=...): # -> TensorListPopBack:
  r"""Returns the last element of the input list as well as a list with all but that element.

  Fails if the list is empty.

  input_handle: the input list
  tensor: the withdrawn last element of the list
  element_dtype: the type of elements in the list
  element_shape: the shape of the output tensor

  Args:
    input_handle: A `Tensor` of type `variant`.
    element_shape: A `Tensor` of type `int32`.
    element_dtype: A `tf.DType`.
    name: A name for the operation (optional).

  Returns:
    A tuple of `Tensor` objects (output_handle, tensor).

    output_handle: A `Tensor` of type `variant`.
    tensor: A `Tensor` of type `element_dtype`.
  """
  ...

TensorListPopBack = ...
def tensor_list_pop_back_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], element_shape: Annotated[Any, _atypes.Int32], element_dtype: TV_TensorListPopBack_element_dtype, name, ctx): # -> TensorListPopBack:
  ...

TV_TensorListPushBack_element_dtype = TypeVar("TV_TensorListPushBack_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def tensor_list_push_back(input_handle: Annotated[Any, _atypes.Variant], tensor: Annotated[Any, TV_TensorListPushBack_element_dtype], name=...) -> Annotated[Any, _atypes.Variant]:
  r"""Returns a list which has the passed-in `Tensor` as last element and the other elements of the given list in `input_handle`.

  tensor: The tensor to put on the list.
  input_handle: The old list.
  output_handle: A list with the elements of the old list followed by tensor.
  element_dtype: the type of elements in the list.
  element_shape: a shape compatible with that of elements in the list.

  Args:
    input_handle: A `Tensor` of type `variant`.
    tensor: A `Tensor`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
  ...

TensorListPushBack = ...
def tensor_list_push_back_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], tensor: Annotated[Any, TV_TensorListPushBack_element_dtype], name, ctx) -> Annotated[Any, _atypes.Variant]:
  ...

TV_TensorListPushBackBatch_element_dtype = TypeVar("TV_TensorListPushBackBatch_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def tensor_list_push_back_batch(input_handles: Annotated[Any, _atypes.Variant], tensor: Annotated[Any, TV_TensorListPushBackBatch_element_dtype], name=...) -> Annotated[Any, _atypes.Variant]:
  r"""TODO: add doc.

  Args:
    input_handles: A `Tensor` of type `variant`.
    tensor: A `Tensor`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
  ...

TensorListPushBackBatch = ...
def tensor_list_push_back_batch_eager_fallback(input_handles: Annotated[Any, _atypes.Variant], tensor: Annotated[Any, TV_TensorListPushBackBatch_element_dtype], name, ctx) -> Annotated[Any, _atypes.Variant]:
  ...

TV_TensorListReserve_element_dtype = TypeVar("TV_TensorListReserve_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
TV_TensorListReserve_shape_type = TypeVar("TV_TensorListReserve_shape_type", _atypes.Int32, _atypes.Int64)
def tensor_list_reserve(element_shape: Annotated[Any, TV_TensorListReserve_shape_type], num_elements: Annotated[Any, _atypes.Int32], element_dtype: TV_TensorListReserve_element_dtype, name=...) -> Annotated[Any, _atypes.Variant]:
  r"""List of the given size with empty elements.

  element_shape: the shape of the future elements of the list
  num_elements: the number of elements to reserve
  handle: the output list
  element_dtype: the desired type of elements in the list.

  Args:
    element_shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.
    num_elements: A `Tensor` of type `int32`.
    element_dtype: A `tf.DType`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
  ...

TensorListReserve = ...
def tensor_list_reserve_eager_fallback(element_shape: Annotated[Any, TV_TensorListReserve_shape_type], num_elements: Annotated[Any, _atypes.Int32], element_dtype: TV_TensorListReserve_element_dtype, name, ctx) -> Annotated[Any, _atypes.Variant]:
  ...

def tensor_list_resize(input_handle: Annotated[Any, _atypes.Variant], size: Annotated[Any, _atypes.Int32], name=...) -> Annotated[Any, _atypes.Variant]:
  r"""Resizes the list.

  
  input_handle: the input list
  size: size of the output list

  Args:
    input_handle: A `Tensor` of type `variant`.
    size: A `Tensor` of type `int32`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
  ...

TensorListResize = ...
def tensor_list_resize_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], size: Annotated[Any, _atypes.Int32], name, ctx) -> Annotated[Any, _atypes.Variant]:
  ...

TV_TensorListScatter_element_dtype = TypeVar("TV_TensorListScatter_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
TV_TensorListScatter_shape_type = TypeVar("TV_TensorListScatter_shape_type", _atypes.Int32, _atypes.Int64)
def tensor_list_scatter(tensor: Annotated[Any, TV_TensorListScatter_element_dtype], indices: Annotated[Any, _atypes.Int32], element_shape: Annotated[Any, TV_TensorListScatter_shape_type], name=...) -> Annotated[Any, _atypes.Variant]:
  r"""Creates a TensorList by indexing into a Tensor.

  Each member of the TensorList corresponds to one row of the input tensor,
  specified by the given index (see `tf.gather`).

  tensor: The input tensor.
  indices: The indices used to index into the list.
  element_shape: The shape of the elements in the list (can be less specified than
    the shape of the tensor).
  output_handle: The TensorList.

  Args:
    tensor: A `Tensor`.
    indices: A `Tensor` of type `int32`.
    element_shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
  ...

TensorListScatter = ...
def tensor_list_scatter_eager_fallback(tensor: Annotated[Any, TV_TensorListScatter_element_dtype], indices: Annotated[Any, _atypes.Int32], element_shape: Annotated[Any, TV_TensorListScatter_shape_type], name, ctx) -> Annotated[Any, _atypes.Variant]:
  ...

TV_TensorListScatterIntoExistingList_element_dtype = TypeVar("TV_TensorListScatterIntoExistingList_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def tensor_list_scatter_into_existing_list(input_handle: Annotated[Any, _atypes.Variant], tensor: Annotated[Any, TV_TensorListScatterIntoExistingList_element_dtype], indices: Annotated[Any, _atypes.Int32], name=...) -> Annotated[Any, _atypes.Variant]:
  r"""Scatters tensor at indices in an input list.

  Each member of the TensorList corresponds to one row of the input tensor,
  specified by the given index (see `tf.gather`).

  input_handle: The list to scatter into.
  tensor: The input tensor.
  indices: The indices used to index into the list.
  output_handle: The TensorList.

  Args:
    input_handle: A `Tensor` of type `variant`.
    tensor: A `Tensor`.
    indices: A `Tensor` of type `int32`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
  ...

TensorListScatterIntoExistingList = ...
def tensor_list_scatter_into_existing_list_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], tensor: Annotated[Any, TV_TensorListScatterIntoExistingList_element_dtype], indices: Annotated[Any, _atypes.Int32], name, ctx) -> Annotated[Any, _atypes.Variant]:
  ...

TV_TensorListScatterV2_element_dtype = TypeVar("TV_TensorListScatterV2_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
TV_TensorListScatterV2_shape_type = TypeVar("TV_TensorListScatterV2_shape_type", _atypes.Int32, _atypes.Int64)
def tensor_list_scatter_v2(tensor: Annotated[Any, TV_TensorListScatterV2_element_dtype], indices: Annotated[Any, _atypes.Int32], element_shape: Annotated[Any, TV_TensorListScatterV2_shape_type], num_elements: Annotated[Any, _atypes.Int32], name=...) -> Annotated[Any, _atypes.Variant]:
  r"""Creates a TensorList by indexing into a Tensor.

  Each member of the TensorList corresponds to one row of the input tensor,
  specified by the given index (see `tf.gather`).

  tensor: The input tensor.
  indices: The indices used to index into the list.
  element_shape: The shape of the elements in the list (can be less specified than
    the shape of the tensor).
  num_elements: The size of the output list. Must be large enough to accommodate
    the largest index in indices. If -1, the list is just large enough to include
    the largest index in indices.
  output_handle: The TensorList.

  Args:
    tensor: A `Tensor`.
    indices: A `Tensor` of type `int32`.
    element_shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.
    num_elements: A `Tensor` of type `int32`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
  ...

TensorListScatterV2 = ...
def tensor_list_scatter_v2_eager_fallback(tensor: Annotated[Any, TV_TensorListScatterV2_element_dtype], indices: Annotated[Any, _atypes.Int32], element_shape: Annotated[Any, TV_TensorListScatterV2_shape_type], num_elements: Annotated[Any, _atypes.Int32], name, ctx) -> Annotated[Any, _atypes.Variant]:
  ...

TV_TensorListSetItem_element_dtype = TypeVar("TV_TensorListSetItem_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def tensor_list_set_item(input_handle: Annotated[Any, _atypes.Variant], index: Annotated[Any, _atypes.Int32], item: Annotated[Any, TV_TensorListSetItem_element_dtype], resize_if_index_out_of_bounds: bool = ..., name=...) -> Annotated[Any, _atypes.Variant]:
  r"""Sets the index-th position of the list to contain the given tensor.

  input_handle: the list
  index: the position in the list to which the tensor will be assigned
  item: the element to be assigned to that position
  output_handle: the new list, with the element in the proper position

  Args:
    input_handle: A `Tensor` of type `variant`.
    index: A `Tensor` of type `int32`.
    item: A `Tensor`.
    resize_if_index_out_of_bounds: An optional `bool`. Defaults to `False`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
  ...

TensorListSetItem = ...
def tensor_list_set_item_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], index: Annotated[Any, _atypes.Int32], item: Annotated[Any, TV_TensorListSetItem_element_dtype], resize_if_index_out_of_bounds: bool, name, ctx) -> Annotated[Any, _atypes.Variant]:
  ...

TV_TensorListSplit_element_dtype = TypeVar("TV_TensorListSplit_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
TV_TensorListSplit_shape_type = TypeVar("TV_TensorListSplit_shape_type", _atypes.Int32, _atypes.Int64)
def tensor_list_split(tensor: Annotated[Any, TV_TensorListSplit_element_dtype], element_shape: Annotated[Any, TV_TensorListSplit_shape_type], lengths: Annotated[Any, _atypes.Int64], name=...) -> Annotated[Any, _atypes.Variant]:
  r"""Splits a tensor into a list.

  list[i] corresponds to lengths[i] tensors from the input tensor.
  The tensor must have rank at least 1 and contain exactly sum(lengths) elements.

  tensor: The input tensor.
  element_shape: A shape compatible with that of elements in the tensor.
  lengths: Vector of sizes of the 0th dimension of tensors in the list.
  output_handle: The list.

  Args:
    tensor: A `Tensor`.
    element_shape: A `Tensor`. Must be one of the following types: `int32`, `int64`.
    lengths: A `Tensor` of type `int64`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
  ...

TensorListSplit = ...
def tensor_list_split_eager_fallback(tensor: Annotated[Any, TV_TensorListSplit_element_dtype], element_shape: Annotated[Any, TV_TensorListSplit_shape_type], lengths: Annotated[Any, _atypes.Int64], name, ctx) -> Annotated[Any, _atypes.Variant]:
  ...

TV_TensorListStack_element_dtype = TypeVar("TV_TensorListStack_element_dtype", _atypes.BFloat16, _atypes.Bool, _atypes.Complex128, _atypes.Complex64, _atypes.Float16, _atypes.Float32, _atypes.Float64, _atypes.Float8e4m3fn, _atypes.Float8e5m2, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int4, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.Resource, _atypes.String, _atypes.UInt16, _atypes.UInt32, _atypes.UInt4, _atypes.UInt64, _atypes.UInt8, _atypes.Variant)
def tensor_list_stack(input_handle: Annotated[Any, _atypes.Variant], element_shape: Annotated[Any, _atypes.Int32], element_dtype: TV_TensorListStack_element_dtype, num_elements: int = ..., name=...) -> Annotated[Any, TV_TensorListStack_element_dtype]:
  r"""Stacks all tensors in the list.

  Requires that all tensors have the same shape.

  input_handle: the input list
  tensor: the gathered result
  num_elements: optional. If not -1, the number of elements in the list.

  Args:
    input_handle: A `Tensor` of type `variant`.
    element_shape: A `Tensor` of type `int32`.
    element_dtype: A `tf.DType`.
    num_elements: An optional `int`. Defaults to `-1`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `element_dtype`.
  """
  ...

TensorListStack = ...
def tensor_list_stack_eager_fallback(input_handle: Annotated[Any, _atypes.Variant], element_shape: Annotated[Any, _atypes.Int32], element_dtype: TV_TensorListStack_element_dtype, num_elements: int, name, ctx) -> Annotated[Any, TV_TensorListStack_element_dtype]:
  ...

