"""
This type stub file was generated by pyright.
"""

from tensorflow.python.ops.numpy_ops import np_utils
from tensorflow.python.util import tf_export

"""Mathematical operations."""
pi = ...
e = ...
inf = ...
@tf_export.tf_export('experimental.numpy.dot', v1=[])
@np_utils.np_doc_only('dot')
def dot(a, b): # -> defaultdict[Any, Any] | Any | list[Any] | tuple[Any, ...] | None:
  ...

@tf_export.tf_export('experimental.numpy.add', v1=[])
@np_utils.np_doc('add')
def add(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.subtract', v1=[])
@np_utils.np_doc('subtract')
def subtract(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.multiply', v1=[])
@np_utils.np_doc('multiply')
def multiply(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.true_divide', v1=[])
@np_utils.np_doc('true_divide')
def true_divide(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.divide', v1=[])
@np_utils.np_doc('divide')
def divide(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.floor_divide', v1=[])
@np_utils.np_doc('floor_divide')
def floor_divide(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.mod', v1=[])
@np_utils.np_doc('mod')
def mod(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.remainder', v1=[])
@np_utils.np_doc('remainder')
def remainder(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.divmod', v1=[])
@np_utils.np_doc('divmod')
def divmod(x1, x2): # -> tuple[Any, Any]:
  ...

@tf_export.tf_export('experimental.numpy.maximum', v1=[])
@np_utils.np_doc('maximum')
def maximum(x1, x2): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.minimum', v1=[])
@np_utils.np_doc('minimum')
def minimum(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.clip', v1=[])
@np_utils.np_doc('clip')
def clip(a, a_min, a_max): # -> Any | IndexedSlices:
  ...

@tf_export.tf_export('experimental.numpy.matmul', v1=[])
@np_utils.np_doc('matmul')
def matmul(x1, x2): # -> defaultdict[Any, Any] | Any | list[Any] | tuple[Any, ...] | None:
  ...

@tf_export.tf_export('experimental.numpy.tensordot', v1=[])
@np_utils.np_doc('tensordot')
def tensordot(a, b, axes=...): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.inner', v1=[])
@np_utils.np_doc_only('inner')
def inner(a, b): # -> defaultdict[Any, Any] | Any | list[Any] | tuple[Any, ...] | None:
  ...

@tf_export.tf_export('experimental.numpy.cross', v1=[])
@np_utils.np_doc('cross')
def cross(a, b, axisa=..., axisb=..., axisc=..., axis=...): # -> defaultdict[Any, Any] | Any | list[Any] | tuple[Any, ...] | None:
  ...

@tf_export.tf_export('experimental.numpy.vdot', v1=[])
@np_utils.np_doc_only('vdot')
def vdot(a, b): # -> defaultdict[Any, Any] | Any | list[Any] | tuple[Any, ...] | None:
  ...

@tf_export.tf_export('experimental.numpy.power', v1=[])
@np_utils.np_doc('power')
def power(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.float_power', v1=[])
@np_utils.np_doc('float_power')
def float_power(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.arctan2', v1=[])
@np_utils.np_doc('arctan2')
def arctan2(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.nextafter', v1=[])
@np_utils.np_doc('nextafter')
def nextafter(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.heaviside', v1=[])
@np_utils.np_doc('heaviside')
def heaviside(x1, x2): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.hypot', v1=[])
@np_utils.np_doc('hypot')
def hypot(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.kron', v1=[])
@np_utils.np_doc('kron')
def kron(a, b): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.outer', v1=[])
@np_utils.np_doc('outer')
def outer(a, b): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.logaddexp', v1=[])
@np_utils.np_doc('logaddexp')
def logaddexp(x1, x2): # -> object | tuple[Any, ...] | list[Any] | Any:
  ...

@tf_export.tf_export('experimental.numpy.logaddexp2', v1=[])
@np_utils.np_doc('logaddexp2')
def logaddexp2(x1, x2): # -> object | tuple[Any, ...] | list[Any] | Any:
  ...

@tf_export.tf_export('experimental.numpy.polyval', v1=[])
@np_utils.np_doc('polyval')
def polyval(p, x): # -> Any | SymbolicTensor:
  ...

@tf_export.tf_export('experimental.numpy.isclose', v1=[])
@np_utils.np_doc('isclose')
def isclose(a, b, rtol=..., atol=..., equal_nan=...): # -> bool | Any:
  ...

@tf_export.tf_export('experimental.numpy.allclose', v1=[])
@np_utils.np_doc('allclose')
def allclose(a, b, rtol=..., atol=..., equal_nan=...):
  ...

@tf_export.tf_export('experimental.numpy.gcd', v1=[])
@np_utils.np_doc('gcd')
def gcd(x1, x2): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.lcm', v1=[])
@np_utils.np_doc('lcm')
def lcm(x1, x2): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.bitwise_and', v1=[])
@np_utils.np_doc('bitwise_and')
def bitwise_and(x1, x2): # -> Tensor | SparseTensor | IndexedSlices | SymbolicTensor:
  ...

@tf_export.tf_export('experimental.numpy.bitwise_or', v1=[])
@np_utils.np_doc('bitwise_or')
def bitwise_or(x1, x2): # -> Tensor | SparseTensor | IndexedSlices | SymbolicTensor:
  ...

@tf_export.tf_export('experimental.numpy.bitwise_xor', v1=[])
@np_utils.np_doc('bitwise_xor')
def bitwise_xor(x1, x2): # -> Tensor | SparseTensor | IndexedSlices | SymbolicTensor:
  ...

@tf_export.tf_export('experimental.numpy.bitwise_not', v1=[])
@np_utils.np_doc('bitwise_not', link=np_utils.AliasOf('invert'))
def bitwise_not(x): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.log', v1=[])
@np_utils.np_doc('log')
def log(x):
  ...

@tf_export.tf_export('experimental.numpy.exp', v1=[])
@np_utils.np_doc('exp')
def exp(x):
  ...

@tf_export.tf_export('experimental.numpy.sqrt', v1=[])
@np_utils.np_doc('sqrt')
def sqrt(x):
  ...

@tf_export.tf_export('experimental.numpy.abs', v1=[])
@np_utils.np_doc('abs', link=np_utils.AliasOf('absolute'))
def abs(x):
  ...

@tf_export.tf_export('experimental.numpy.absolute', v1=[])
@np_utils.np_doc('absolute')
def absolute(x):
  ...

@tf_export.tf_export('experimental.numpy.fabs', v1=[])
@np_utils.np_doc('fabs')
def fabs(x):
  ...

@tf_export.tf_export('experimental.numpy.ceil', v1=[])
@np_utils.np_doc('ceil')
def ceil(x):
  ...

@tf_export.tf_export('experimental.numpy.floor', v1=[])
@np_utils.np_doc('floor')
def floor(x):
  ...

@tf_export.tf_export('experimental.numpy.conj', v1=[])
@np_utils.np_doc('conj')
def conj(x): # -> Tensor | SymbolicTensor:
  ...

@tf_export.tf_export('experimental.numpy.negative', v1=[])
@np_utils.np_doc('negative')
def negative(x):
  ...

@tf_export.tf_export('experimental.numpy.reciprocal', v1=[])
@np_utils.np_doc('reciprocal')
def reciprocal(x):
  ...

@tf_export.tf_export('experimental.numpy.signbit', v1=[])
@np_utils.np_doc('signbit')
def signbit(x): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.sin', v1=[])
@np_utils.np_doc('sin')
def sin(x):
  ...

@tf_export.tf_export('experimental.numpy.cos', v1=[])
@np_utils.np_doc('cos')
def cos(x):
  ...

@tf_export.tf_export('experimental.numpy.tan', v1=[])
@np_utils.np_doc('tan')
def tan(x):
  ...

@tf_export.tf_export('experimental.numpy.sinh', v1=[])
@np_utils.np_doc('sinh')
def sinh(x):
  ...

@tf_export.tf_export('experimental.numpy.cosh', v1=[])
@np_utils.np_doc('cosh')
def cosh(x):
  ...

@tf_export.tf_export('experimental.numpy.tanh', v1=[])
@np_utils.np_doc('tanh')
def tanh(x):
  ...

@tf_export.tf_export('experimental.numpy.arcsin', v1=[])
@np_utils.np_doc('arcsin')
def arcsin(x):
  ...

@tf_export.tf_export('experimental.numpy.arccos', v1=[])
@np_utils.np_doc('arccos')
def arccos(x):
  ...

@tf_export.tf_export('experimental.numpy.arctan', v1=[])
@np_utils.np_doc('arctan')
def arctan(x):
  ...

@tf_export.tf_export('experimental.numpy.arcsinh', v1=[])
@np_utils.np_doc('arcsinh')
def arcsinh(x):
  ...

@tf_export.tf_export('experimental.numpy.arccosh', v1=[])
@np_utils.np_doc('arccosh')
def arccosh(x):
  ...

@tf_export.tf_export('experimental.numpy.arctanh', v1=[])
@np_utils.np_doc('arctanh')
def arctanh(x):
  ...

@tf_export.tf_export('experimental.numpy.deg2rad', v1=[])
@np_utils.np_doc('deg2rad')
def deg2rad(x): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.rad2deg', v1=[])
@np_utils.np_doc('rad2deg')
def rad2deg(x):
  ...

_tf_float_types = ...
@tf_export.tf_export('experimental.numpy.angle', v1=[])
@np_utils.np_doc('angle')
def angle(z, deg=...): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.cbrt', v1=[])
@np_utils.np_doc('cbrt')
def cbrt(x): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.conjugate', v1=[])
@np_utils.np_doc('conjugate', link=np_utils.AliasOf('conj'))
def conjugate(x): # -> Tensor | SymbolicTensor:
  ...

@tf_export.tf_export('experimental.numpy.exp2', v1=[])
@np_utils.np_doc('exp2')
def exp2(x): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.expm1', v1=[])
@np_utils.np_doc('expm1')
def expm1(x):
  ...

@tf_export.tf_export('experimental.numpy.fix', v1=[])
@np_utils.np_doc('fix')
def fix(x): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.iscomplex', v1=[])
@np_utils.np_doc('iscomplex')
def iscomplex(x): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.isreal', v1=[])
@np_utils.np_doc('isreal')
def isreal(x): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.iscomplexobj', v1=[])
@np_utils.np_doc('iscomplexobj')
def iscomplexobj(x): # -> bool:
  ...

@tf_export.tf_export('experimental.numpy.isrealobj', v1=[])
@np_utils.np_doc('isrealobj')
def isrealobj(x): # -> bool:
  ...

@tf_export.tf_export('experimental.numpy.isnan', v1=[])
@np_utils.np_doc('isnan')
def isnan(x):
  ...

nansum = ...
nanprod = ...
@tf_export.tf_export('experimental.numpy.nanmean', v1=[])
@np_utils.np_doc('nanmean')
def nanmean(a, axis=..., dtype=..., keepdims=...):
  ...

@tf_export.tf_export('experimental.numpy.isfinite', v1=[])
@np_utils.np_doc('isfinite')
def isfinite(x):
  ...

@tf_export.tf_export('experimental.numpy.isinf', v1=[])
@np_utils.np_doc('isinf')
def isinf(x): # -> Literal[False]:
  ...

@tf_export.tf_export('experimental.numpy.isneginf', v1=[])
@np_utils.np_doc('isneginf')
def isneginf(x): # -> Literal[False]:
  ...

@tf_export.tf_export('experimental.numpy.isposinf', v1=[])
@np_utils.np_doc('isposinf')
def isposinf(x): # -> Literal[False]:
  ...

@tf_export.tf_export('experimental.numpy.log2', v1=[])
@np_utils.np_doc('log2')
def log2(x):
  ...

@tf_export.tf_export('experimental.numpy.log10', v1=[])
@np_utils.np_doc('log10')
def log10(x):
  ...

@tf_export.tf_export('experimental.numpy.log1p', v1=[])
@np_utils.np_doc('log1p')
def log1p(x):
  ...

@tf_export.tf_export('experimental.numpy.positive', v1=[])
@np_utils.np_doc('positive')
def positive(x):
  ...

@tf_export.tf_export('experimental.numpy.sinc', v1=[])
@np_utils.np_doc('sinc')
def sinc(x): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.square', v1=[])
@np_utils.np_doc('square')
def square(x):
  ...

@tf_export.tf_export('experimental.numpy.diff', v1=[])
@np_utils.np_doc('diff')
def diff(a, n=..., axis=...): # -> Any | ndarray | defaultdict[Any, Any] | list[Any] | object | SparseTensor | IndexedSlices | SymbolicTensor | tuple[Any, ...] | None:
  ...

@tf_export.tf_export('experimental.numpy.equal', v1=[])
@np_utils.np_doc('equal')
def equal(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.not_equal', v1=[])
@np_utils.np_doc('not_equal')
def not_equal(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.greater', v1=[])
@np_utils.np_doc('greater')
def greater(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.greater_equal', v1=[])
@np_utils.np_doc('greater_equal')
def greater_equal(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.less', v1=[])
@np_utils.np_doc('less')
def less(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.less_equal', v1=[])
@np_utils.np_doc('less_equal')
def less_equal(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.array_equal', v1=[])
@np_utils.np_doc('array_equal')
def array_equal(a1, a2): # -> defaultdict[Any, Any] | Any | list[Any] | tuple[Any, ...] | None:
  ...

@tf_export.tf_export('experimental.numpy.logical_and', v1=[])
@np_utils.np_doc('logical_and')
def logical_and(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.logical_or', v1=[])
@np_utils.np_doc('logical_or')
def logical_or(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.logical_xor', v1=[])
@np_utils.np_doc('logical_xor')
def logical_xor(x1, x2):
  ...

@tf_export.tf_export('experimental.numpy.logical_not', v1=[])
@np_utils.np_doc('logical_not')
def logical_not(x):
  ...

@tf_export.tf_export('experimental.numpy.linspace', v1=[])
@np_utils.np_doc('linspace')
def linspace(start, stop, num=..., endpoint=..., retstep=..., dtype=..., axis=...): # -> tuple[Tensor | Any | SparseTensor | IndexedSlices | SymbolicTensor, Any | SymbolicTensor] | Tensor | SparseTensor | IndexedSlices | SymbolicTensor | Any:
  ...

@tf_export.tf_export('experimental.numpy.logspace', v1=[])
@np_utils.np_doc('logspace')
def logspace(start, stop, num=..., endpoint=..., base=..., dtype=..., axis=...): # -> Tensor | SparseTensor | IndexedSlices | SymbolicTensor:
  ...

@tf_export.tf_export('experimental.numpy.geomspace', v1=[])
@np_utils.np_doc('geomspace')
def geomspace(start, stop, num=..., endpoint=..., dtype=..., axis=...): # -> Tensor | SparseTensor | IndexedSlices | SymbolicTensor:
  ...

@tf_export.tf_export('experimental.numpy.ptp', v1=[])
@np_utils.np_doc('ptp')
def ptp(a, axis=..., keepdims=...):
  ...

@tf_export.tf_export('experimental.numpy.concatenate', v1=[])
@np_utils.np_doc_only('concatenate')
def concatenate(arys, axis=...): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
  ...

@tf_export.tf_export('experimental.numpy.tile', v1=[])
@np_utils.np_doc_only('tile')
def tile(a, reps): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.count_nonzero', v1=[])
@np_utils.np_doc('count_nonzero')
def count_nonzero(a, axis=...): # -> Tensor | SparseTensor | IndexedSlices | SymbolicTensor:
  ...

@tf_export.tf_export('experimental.numpy.argsort', v1=[])
@np_utils.np_doc('argsort')
def argsort(a, axis=..., kind=..., order=...): # -> defaultdict[Any, Any] | Any | list[Any] | object | Tensor | SparseTensor | IndexedSlices | SymbolicTensor | tuple[Any, ...] | None:
  ...

@tf_export.tf_export('experimental.numpy.sort', v1=[])
@np_utils.np_doc('sort')
def sort(a, axis=..., kind=..., order=...): # -> Any:
  ...

@tf_export.tf_export('experimental.numpy.argmax', v1=[])
@np_utils.np_doc('argmax')
def argmax(a, axis=...):
  ...

@tf_export.tf_export('experimental.numpy.argmin', v1=[])
@np_utils.np_doc('argmin')
def argmin(a, axis=...):
  ...

@tf_export.tf_export('experimental.numpy.append', v1=[])
@np_utils.np_doc('append')
def append(arr, values, axis=...): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
  ...

@tf_export.tf_export('experimental.numpy.average', v1=[])
@np_utils.np_doc('average')
def average(a, axis=..., weights=..., returned=...): # -> tuple[Any | defaultdict[Any, Any] | list[Any] | object | Tensor | SparseTensor | IndexedSlices | SymbolicTensor | tuple[Any, ...] | None, Any] | defaultdict[Any, Any] | Any | list[Any] | object | Tensor | SparseTensor | IndexedSlices | SymbolicTensor | tuple[Any, ...] | None:
  ...

@tf_export.tf_export('experimental.numpy.trace', v1=[])
@np_utils.np_doc('trace')
def trace(a, offset=..., axis1=..., axis2=..., dtype=...):
  ...

@tf_export.tf_export('experimental.numpy.meshgrid', v1=[])
@np_utils.np_doc('meshgrid')
def meshgrid(*xi, **kwargs): # -> list[Any]:
  """This currently requires copy=True and sparse=False."""
  ...

@tf_export.tf_export('experimental.numpy.einsum', v1=[])
@np_utils.np_doc_only('einsum')
def einsum(subscripts, *operands, **kwargs): # -> Any:
  ...

def enable_numpy_methods_on_tensor(): # -> None:
  """Adds additional NumPy methods on tf.Tensor class."""
  ...

