"""
This type stub file was generated by pyright.
"""

from tensorflow.security.fuzzing.py import annotation_types as _atypes
from typing import Any, TypeVar
from typing_extensions import Annotated

"""Python wrappers around TensorFlow ops.

This file is MACHINE GENERATED! Do not edit.
"""
TV_ApplyAdaMax_T = TypeVar("TV_ApplyAdaMax_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_ada_max(var: Annotated[Any, TV_ApplyAdaMax_T], m: Annotated[Any, TV_ApplyAdaMax_T], v: Annotated[Any, TV_ApplyAdaMax_T], beta1_power: Annotated[Any, TV_ApplyAdaMax_T], lr: Annotated[Any, TV_ApplyAdaMax_T], beta1: Annotated[Any, TV_ApplyAdaMax_T], beta2: Annotated[Any, TV_ApplyAdaMax_T], epsilon: Annotated[Any, TV_ApplyAdaMax_T], grad: Annotated[Any, TV_ApplyAdaMax_T], use_locking: bool = ..., name=...) -> Annotated[Any, TV_ApplyAdaMax_T]:
  r"""Update '*var' according to the AdaMax algorithm.

  m_t <- beta1 * m_{t-1} + (1 - beta1) * g
  v_t <- max(beta2 * v_{t-1}, abs(g))
  variable <- variable - learning_rate / (1 - beta1^t) * m_t / (v_t + epsilon)

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    m: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    v: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    beta1_power: A `Tensor`. Must have the same type as `var`.
      Must be a scalar.
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    beta1: A `Tensor`. Must have the same type as `var`.
      Momentum factor. Must be a scalar.
    beta2: A `Tensor`. Must have the same type as `var`.
      Momentum factor. Must be a scalar.
    epsilon: A `Tensor`. Must have the same type as `var`.
      Ridge term. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var, m, and v tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyAdaMax = ...
def apply_ada_max_eager_fallback(var: Annotated[Any, TV_ApplyAdaMax_T], m: Annotated[Any, TV_ApplyAdaMax_T], v: Annotated[Any, TV_ApplyAdaMax_T], beta1_power: Annotated[Any, TV_ApplyAdaMax_T], lr: Annotated[Any, TV_ApplyAdaMax_T], beta1: Annotated[Any, TV_ApplyAdaMax_T], beta2: Annotated[Any, TV_ApplyAdaMax_T], epsilon: Annotated[Any, TV_ApplyAdaMax_T], grad: Annotated[Any, TV_ApplyAdaMax_T], use_locking: bool, name, ctx) -> Annotated[Any, TV_ApplyAdaMax_T]:
  ...

TV_ApplyAdadelta_T = TypeVar("TV_ApplyAdadelta_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_adadelta(var: Annotated[Any, TV_ApplyAdadelta_T], accum: Annotated[Any, TV_ApplyAdadelta_T], accum_update: Annotated[Any, TV_ApplyAdadelta_T], lr: Annotated[Any, TV_ApplyAdadelta_T], rho: Annotated[Any, TV_ApplyAdadelta_T], epsilon: Annotated[Any, TV_ApplyAdadelta_T], grad: Annotated[Any, TV_ApplyAdadelta_T], use_locking: bool = ..., name=...) -> Annotated[Any, TV_ApplyAdadelta_T]:
  r"""Update '*var' according to the adadelta scheme.

  accum = rho() * accum + (1 - rho()) * grad.square();
  update = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;
  update_accum = rho() * update_accum + (1 - rho()) * update.square();
  var -= update;

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    accum: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    accum_update: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    rho: A `Tensor`. Must have the same type as `var`.
      Decay factor. Must be a scalar.
    epsilon: A `Tensor`. Must have the same type as `var`.
      Constant factor. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, updating of the var, accum and update_accum tensors will be protected by
      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyAdadelta = ...
def apply_adadelta_eager_fallback(var: Annotated[Any, TV_ApplyAdadelta_T], accum: Annotated[Any, TV_ApplyAdadelta_T], accum_update: Annotated[Any, TV_ApplyAdadelta_T], lr: Annotated[Any, TV_ApplyAdadelta_T], rho: Annotated[Any, TV_ApplyAdadelta_T], epsilon: Annotated[Any, TV_ApplyAdadelta_T], grad: Annotated[Any, TV_ApplyAdadelta_T], use_locking: bool, name, ctx) -> Annotated[Any, TV_ApplyAdadelta_T]:
  ...

TV_ApplyAdagrad_T = TypeVar("TV_ApplyAdagrad_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_adagrad(var: Annotated[Any, TV_ApplyAdagrad_T], accum: Annotated[Any, TV_ApplyAdagrad_T], lr: Annotated[Any, TV_ApplyAdagrad_T], grad: Annotated[Any, TV_ApplyAdagrad_T], use_locking: bool = ..., update_slots: bool = ..., name=...) -> Annotated[Any, TV_ApplyAdagrad_T]:
  r"""Update '*var' according to the adagrad scheme.

  accum += grad * grad
  var -= lr * grad * (1 / sqrt(accum))

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    accum: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    update_slots: An optional `bool`. Defaults to `True`.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyAdagrad = ...
def apply_adagrad_eager_fallback(var: Annotated[Any, TV_ApplyAdagrad_T], accum: Annotated[Any, TV_ApplyAdagrad_T], lr: Annotated[Any, TV_ApplyAdagrad_T], grad: Annotated[Any, TV_ApplyAdagrad_T], use_locking: bool, update_slots: bool, name, ctx) -> Annotated[Any, TV_ApplyAdagrad_T]:
  ...

TV_ApplyAdagradDA_T = TypeVar("TV_ApplyAdagradDA_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_adagrad_da(var: Annotated[Any, TV_ApplyAdagradDA_T], gradient_accumulator: Annotated[Any, TV_ApplyAdagradDA_T], gradient_squared_accumulator: Annotated[Any, TV_ApplyAdagradDA_T], grad: Annotated[Any, TV_ApplyAdagradDA_T], lr: Annotated[Any, TV_ApplyAdagradDA_T], l1: Annotated[Any, TV_ApplyAdagradDA_T], l2: Annotated[Any, TV_ApplyAdagradDA_T], global_step: Annotated[Any, _atypes.Int64], use_locking: bool = ..., name=...) -> Annotated[Any, TV_ApplyAdagradDA_T]:
  r"""Update '*var' according to the proximal adagrad scheme.

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    gradient_accumulator: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    gradient_squared_accumulator: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `var`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `var`.
      L2 regularization. Must be a scalar.
    global_step: A `Tensor` of type `int64`.
      Training step number. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, updating of the var and accum tensors will be protected by
      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyAdagradDA = ...
def apply_adagrad_da_eager_fallback(var: Annotated[Any, TV_ApplyAdagradDA_T], gradient_accumulator: Annotated[Any, TV_ApplyAdagradDA_T], gradient_squared_accumulator: Annotated[Any, TV_ApplyAdagradDA_T], grad: Annotated[Any, TV_ApplyAdagradDA_T], lr: Annotated[Any, TV_ApplyAdagradDA_T], l1: Annotated[Any, TV_ApplyAdagradDA_T], l2: Annotated[Any, TV_ApplyAdagradDA_T], global_step: Annotated[Any, _atypes.Int64], use_locking: bool, name, ctx) -> Annotated[Any, TV_ApplyAdagradDA_T]:
  ...

TV_ApplyAdagradV2_T = TypeVar("TV_ApplyAdagradV2_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_adagrad_v2(var: Annotated[Any, TV_ApplyAdagradV2_T], accum: Annotated[Any, TV_ApplyAdagradV2_T], lr: Annotated[Any, TV_ApplyAdagradV2_T], epsilon: Annotated[Any, TV_ApplyAdagradV2_T], grad: Annotated[Any, TV_ApplyAdagradV2_T], use_locking: bool = ..., update_slots: bool = ..., name=...) -> Annotated[Any, TV_ApplyAdagradV2_T]:
  r"""Update '*var' according to the adagrad scheme.

  accum += grad * grad
  var -= lr * grad * (1 / sqrt(accum))

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    accum: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    epsilon: A `Tensor`. Must have the same type as `var`.
      Constant factor. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    update_slots: An optional `bool`. Defaults to `True`.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyAdagradV2 = ...
def apply_adagrad_v2_eager_fallback(var: Annotated[Any, TV_ApplyAdagradV2_T], accum: Annotated[Any, TV_ApplyAdagradV2_T], lr: Annotated[Any, TV_ApplyAdagradV2_T], epsilon: Annotated[Any, TV_ApplyAdagradV2_T], grad: Annotated[Any, TV_ApplyAdagradV2_T], use_locking: bool, update_slots: bool, name, ctx) -> Annotated[Any, TV_ApplyAdagradV2_T]:
  ...

TV_ApplyAdam_T = TypeVar("TV_ApplyAdam_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_adam(var: Annotated[Any, TV_ApplyAdam_T], m: Annotated[Any, TV_ApplyAdam_T], v: Annotated[Any, TV_ApplyAdam_T], beta1_power: Annotated[Any, TV_ApplyAdam_T], beta2_power: Annotated[Any, TV_ApplyAdam_T], lr: Annotated[Any, TV_ApplyAdam_T], beta1: Annotated[Any, TV_ApplyAdam_T], beta2: Annotated[Any, TV_ApplyAdam_T], epsilon: Annotated[Any, TV_ApplyAdam_T], grad: Annotated[Any, TV_ApplyAdam_T], use_locking: bool = ..., use_nesterov: bool = ..., name=...) -> Annotated[Any, TV_ApplyAdam_T]:
  r"""Update '*var' according to the Adam algorithm.

  $$\text{lr}_t := \mathrm{lr} \cdot \frac{\sqrt{1 - \beta_2^t}}{1 - \beta_1^t}$$
  $$m_t := \beta_1 \cdot m_{t-1} + (1 - \beta_1) \cdot g$$
  $$v_t := \beta_2 \cdot v_{t-1} + (1 - \beta_2) \cdot g^2$$
  $$\text{var} := \begin{cases} \text{var} - (m_t \beta_1 + g \cdot (1 - \beta_1))\cdot\text{lr}_t/(\sqrt{v_t} + \epsilon), &\text{if use_nesterov}\\\\  \text{var} - m_t \cdot \text{lr}_t /(\sqrt{v_t} + \epsilon), &\text{otherwise} \end{cases}$$

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    m: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    v: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    beta1_power: A `Tensor`. Must have the same type as `var`.
      Must be a scalar.
    beta2_power: A `Tensor`. Must have the same type as `var`.
      Must be a scalar.
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    beta1: A `Tensor`. Must have the same type as `var`.
      Momentum factor. Must be a scalar.
    beta2: A `Tensor`. Must have the same type as `var`.
      Momentum factor. Must be a scalar.
    epsilon: A `Tensor`. Must have the same type as `var`.
      Ridge term. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var, m, and v tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    use_nesterov: An optional `bool`. Defaults to `False`.
      If `True`, uses the nesterov update.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyAdam = ...
def apply_adam_eager_fallback(var: Annotated[Any, TV_ApplyAdam_T], m: Annotated[Any, TV_ApplyAdam_T], v: Annotated[Any, TV_ApplyAdam_T], beta1_power: Annotated[Any, TV_ApplyAdam_T], beta2_power: Annotated[Any, TV_ApplyAdam_T], lr: Annotated[Any, TV_ApplyAdam_T], beta1: Annotated[Any, TV_ApplyAdam_T], beta2: Annotated[Any, TV_ApplyAdam_T], epsilon: Annotated[Any, TV_ApplyAdam_T], grad: Annotated[Any, TV_ApplyAdam_T], use_locking: bool, use_nesterov: bool, name, ctx) -> Annotated[Any, TV_ApplyAdam_T]:
  ...

TV_ApplyAddSign_T = TypeVar("TV_ApplyAddSign_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_add_sign(var: Annotated[Any, TV_ApplyAddSign_T], m: Annotated[Any, TV_ApplyAddSign_T], lr: Annotated[Any, TV_ApplyAddSign_T], alpha: Annotated[Any, TV_ApplyAddSign_T], sign_decay: Annotated[Any, TV_ApplyAddSign_T], beta: Annotated[Any, TV_ApplyAddSign_T], grad: Annotated[Any, TV_ApplyAddSign_T], use_locking: bool = ..., name=...) -> Annotated[Any, TV_ApplyAddSign_T]:
  r"""Update '*var' according to the AddSign update.

  m_t <- beta1 * m_{t-1} + (1 - beta1) * g
  update <- (alpha + sign_decay * sign(g) *sign(m)) * g
  variable <- variable - lr_t * update

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    m: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    alpha: A `Tensor`. Must have the same type as `var`. Must be a scalar.
    sign_decay: A `Tensor`. Must have the same type as `var`.
      Must be a scalar.
    beta: A `Tensor`. Must have the same type as `var`. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and m tensors is
      protected by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyAddSign = ...
def apply_add_sign_eager_fallback(var: Annotated[Any, TV_ApplyAddSign_T], m: Annotated[Any, TV_ApplyAddSign_T], lr: Annotated[Any, TV_ApplyAddSign_T], alpha: Annotated[Any, TV_ApplyAddSign_T], sign_decay: Annotated[Any, TV_ApplyAddSign_T], beta: Annotated[Any, TV_ApplyAddSign_T], grad: Annotated[Any, TV_ApplyAddSign_T], use_locking: bool, name, ctx) -> Annotated[Any, TV_ApplyAddSign_T]:
  ...

TV_ApplyCenteredRMSProp_T = TypeVar("TV_ApplyCenteredRMSProp_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_centered_rms_prop(var: Annotated[Any, TV_ApplyCenteredRMSProp_T], mg: Annotated[Any, TV_ApplyCenteredRMSProp_T], ms: Annotated[Any, TV_ApplyCenteredRMSProp_T], mom: Annotated[Any, TV_ApplyCenteredRMSProp_T], lr: Annotated[Any, TV_ApplyCenteredRMSProp_T], rho: Annotated[Any, TV_ApplyCenteredRMSProp_T], momentum: Annotated[Any, TV_ApplyCenteredRMSProp_T], epsilon: Annotated[Any, TV_ApplyCenteredRMSProp_T], grad: Annotated[Any, TV_ApplyCenteredRMSProp_T], use_locking: bool = ..., name=...) -> Annotated[Any, TV_ApplyCenteredRMSProp_T]:
  r"""Update '*var' according to the centered RMSProp algorithm.

  The centered RMSProp algorithm uses an estimate of the centered second moment
  (i.e., the variance) for normalization, as opposed to regular RMSProp, which
  uses the (uncentered) second moment. This often helps with training, but is
  slightly more expensive in terms of computation and memory.

  Note that in dense implementation of this algorithm, mg, ms, and mom will
  update even if the grad is zero, but in this sparse implementation, mg, ms,
  and mom will not update in iterations during which the grad is zero.

  mean_square = decay * mean_square + (1-decay) * gradient ** 2
  mean_grad = decay * mean_grad + (1-decay) * gradient

  Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)

  mg <- rho * mg_{t-1} + (1-rho) * grad
  ms <- rho * ms_{t-1} + (1-rho) * grad * grad
  mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)
  var <- var - mom

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    mg: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    ms: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    mom: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    rho: A `Tensor`. Must have the same type as `var`.
      Decay rate. Must be a scalar.
    momentum: A `Tensor`. Must have the same type as `var`.
      Momentum Scale. Must be a scalar.
    epsilon: A `Tensor`. Must have the same type as `var`.
      Ridge term. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var, mg, ms, and mom tensors is
      protected by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyCenteredRMSProp = ...
def apply_centered_rms_prop_eager_fallback(var: Annotated[Any, TV_ApplyCenteredRMSProp_T], mg: Annotated[Any, TV_ApplyCenteredRMSProp_T], ms: Annotated[Any, TV_ApplyCenteredRMSProp_T], mom: Annotated[Any, TV_ApplyCenteredRMSProp_T], lr: Annotated[Any, TV_ApplyCenteredRMSProp_T], rho: Annotated[Any, TV_ApplyCenteredRMSProp_T], momentum: Annotated[Any, TV_ApplyCenteredRMSProp_T], epsilon: Annotated[Any, TV_ApplyCenteredRMSProp_T], grad: Annotated[Any, TV_ApplyCenteredRMSProp_T], use_locking: bool, name, ctx) -> Annotated[Any, TV_ApplyCenteredRMSProp_T]:
  ...

TV_ApplyFtrl_T = TypeVar("TV_ApplyFtrl_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_ftrl(var: Annotated[Any, TV_ApplyFtrl_T], accum: Annotated[Any, TV_ApplyFtrl_T], linear: Annotated[Any, TV_ApplyFtrl_T], grad: Annotated[Any, TV_ApplyFtrl_T], lr: Annotated[Any, TV_ApplyFtrl_T], l1: Annotated[Any, TV_ApplyFtrl_T], l2: Annotated[Any, TV_ApplyFtrl_T], lr_power: Annotated[Any, TV_ApplyFtrl_T], use_locking: bool = ..., multiply_linear_by_lr: bool = ..., name=...) -> Annotated[Any, TV_ApplyFtrl_T]:
  r"""Update '*var' according to the Ftrl-proximal scheme.

  accum_new = accum + grad * grad
  linear += grad - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
  quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
  var = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0
  accum = accum_new

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    accum: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    linear: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `var`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `var`.
      L2 regularization. Must be a scalar.
    lr_power: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    multiply_linear_by_lr: An optional `bool`. Defaults to `False`.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyFtrl = ...
def apply_ftrl_eager_fallback(var: Annotated[Any, TV_ApplyFtrl_T], accum: Annotated[Any, TV_ApplyFtrl_T], linear: Annotated[Any, TV_ApplyFtrl_T], grad: Annotated[Any, TV_ApplyFtrl_T], lr: Annotated[Any, TV_ApplyFtrl_T], l1: Annotated[Any, TV_ApplyFtrl_T], l2: Annotated[Any, TV_ApplyFtrl_T], lr_power: Annotated[Any, TV_ApplyFtrl_T], use_locking: bool, multiply_linear_by_lr: bool, name, ctx) -> Annotated[Any, TV_ApplyFtrl_T]:
  ...

TV_ApplyFtrlV2_T = TypeVar("TV_ApplyFtrlV2_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_ftrl_v2(var: Annotated[Any, TV_ApplyFtrlV2_T], accum: Annotated[Any, TV_ApplyFtrlV2_T], linear: Annotated[Any, TV_ApplyFtrlV2_T], grad: Annotated[Any, TV_ApplyFtrlV2_T], lr: Annotated[Any, TV_ApplyFtrlV2_T], l1: Annotated[Any, TV_ApplyFtrlV2_T], l2: Annotated[Any, TV_ApplyFtrlV2_T], l2_shrinkage: Annotated[Any, TV_ApplyFtrlV2_T], lr_power: Annotated[Any, TV_ApplyFtrlV2_T], use_locking: bool = ..., multiply_linear_by_lr: bool = ..., name=...) -> Annotated[Any, TV_ApplyFtrlV2_T]:
  r"""Update '*var' according to the Ftrl-proximal scheme.

  grad_with_shrinkage = grad + 2 * l2_shrinkage * var
  accum_new = accum + grad * grad
  linear += grad_with_shrinkage -
      (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
  quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
  var = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0
  accum = accum_new

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    accum: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    linear: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `var`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `var`.
      L2 shrinkage regularization. Must be a scalar.
    l2_shrinkage: A `Tensor`. Must have the same type as `var`.
    lr_power: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    multiply_linear_by_lr: An optional `bool`. Defaults to `False`.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyFtrlV2 = ...
def apply_ftrl_v2_eager_fallback(var: Annotated[Any, TV_ApplyFtrlV2_T], accum: Annotated[Any, TV_ApplyFtrlV2_T], linear: Annotated[Any, TV_ApplyFtrlV2_T], grad: Annotated[Any, TV_ApplyFtrlV2_T], lr: Annotated[Any, TV_ApplyFtrlV2_T], l1: Annotated[Any, TV_ApplyFtrlV2_T], l2: Annotated[Any, TV_ApplyFtrlV2_T], l2_shrinkage: Annotated[Any, TV_ApplyFtrlV2_T], lr_power: Annotated[Any, TV_ApplyFtrlV2_T], use_locking: bool, multiply_linear_by_lr: bool, name, ctx) -> Annotated[Any, TV_ApplyFtrlV2_T]:
  ...

TV_ApplyGradientDescent_T = TypeVar("TV_ApplyGradientDescent_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_gradient_descent(var: Annotated[Any, TV_ApplyGradientDescent_T], alpha: Annotated[Any, TV_ApplyGradientDescent_T], delta: Annotated[Any, TV_ApplyGradientDescent_T], use_locking: bool = ..., name=...) -> Annotated[Any, TV_ApplyGradientDescent_T]:
  r"""Update '*var' by subtracting 'alpha' * 'delta' from it.

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    alpha: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    delta: A `Tensor`. Must have the same type as `var`. The change.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, the subtraction will be protected by a lock;
      otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyGradientDescent = ...
def apply_gradient_descent_eager_fallback(var: Annotated[Any, TV_ApplyGradientDescent_T], alpha: Annotated[Any, TV_ApplyGradientDescent_T], delta: Annotated[Any, TV_ApplyGradientDescent_T], use_locking: bool, name, ctx) -> Annotated[Any, TV_ApplyGradientDescent_T]:
  ...

TV_ApplyMomentum_T = TypeVar("TV_ApplyMomentum_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_momentum(var: Annotated[Any, TV_ApplyMomentum_T], accum: Annotated[Any, TV_ApplyMomentum_T], lr: Annotated[Any, TV_ApplyMomentum_T], grad: Annotated[Any, TV_ApplyMomentum_T], momentum: Annotated[Any, TV_ApplyMomentum_T], use_locking: bool = ..., use_nesterov: bool = ..., name=...) -> Annotated[Any, TV_ApplyMomentum_T]:
  r"""Update '*var' according to the momentum scheme.

  Set use_nesterov = True if you want to use Nesterov momentum.

  accum = accum * momentum + grad
  var -= lr * accum

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    accum: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    momentum: A `Tensor`. Must have the same type as `var`.
      Momentum. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    use_nesterov: An optional `bool`. Defaults to `False`.
      If `True`, the tensor passed to compute grad will be
      var - lr * momentum * accum, so in the end, the var you get is actually
      var - lr * momentum * accum.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyMomentum = ...
def apply_momentum_eager_fallback(var: Annotated[Any, TV_ApplyMomentum_T], accum: Annotated[Any, TV_ApplyMomentum_T], lr: Annotated[Any, TV_ApplyMomentum_T], grad: Annotated[Any, TV_ApplyMomentum_T], momentum: Annotated[Any, TV_ApplyMomentum_T], use_locking: bool, use_nesterov: bool, name, ctx) -> Annotated[Any, TV_ApplyMomentum_T]:
  ...

TV_ApplyPowerSign_T = TypeVar("TV_ApplyPowerSign_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_power_sign(var: Annotated[Any, TV_ApplyPowerSign_T], m: Annotated[Any, TV_ApplyPowerSign_T], lr: Annotated[Any, TV_ApplyPowerSign_T], logbase: Annotated[Any, TV_ApplyPowerSign_T], sign_decay: Annotated[Any, TV_ApplyPowerSign_T], beta: Annotated[Any, TV_ApplyPowerSign_T], grad: Annotated[Any, TV_ApplyPowerSign_T], use_locking: bool = ..., name=...) -> Annotated[Any, TV_ApplyPowerSign_T]:
  r"""Update '*var' according to the AddSign update.

  m_t <- beta1 * m_{t-1} + (1 - beta1) * g
  update <- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g
  variable <- variable - lr_t * update

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    m: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    logbase: A `Tensor`. Must have the same type as `var`. Must be a scalar.
    sign_decay: A `Tensor`. Must have the same type as `var`.
      Must be a scalar.
    beta: A `Tensor`. Must have the same type as `var`. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and m tensors is
      protected by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyPowerSign = ...
def apply_power_sign_eager_fallback(var: Annotated[Any, TV_ApplyPowerSign_T], m: Annotated[Any, TV_ApplyPowerSign_T], lr: Annotated[Any, TV_ApplyPowerSign_T], logbase: Annotated[Any, TV_ApplyPowerSign_T], sign_decay: Annotated[Any, TV_ApplyPowerSign_T], beta: Annotated[Any, TV_ApplyPowerSign_T], grad: Annotated[Any, TV_ApplyPowerSign_T], use_locking: bool, name, ctx) -> Annotated[Any, TV_ApplyPowerSign_T]:
  ...

TV_ApplyProximalAdagrad_T = TypeVar("TV_ApplyProximalAdagrad_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_proximal_adagrad(var: Annotated[Any, TV_ApplyProximalAdagrad_T], accum: Annotated[Any, TV_ApplyProximalAdagrad_T], lr: Annotated[Any, TV_ApplyProximalAdagrad_T], l1: Annotated[Any, TV_ApplyProximalAdagrad_T], l2: Annotated[Any, TV_ApplyProximalAdagrad_T], grad: Annotated[Any, TV_ApplyProximalAdagrad_T], use_locking: bool = ..., name=...) -> Annotated[Any, TV_ApplyProximalAdagrad_T]:
  r"""Update '*var' and '*accum' according to FOBOS with Adagrad learning rate.

  accum += grad * grad
  prox_v = var - lr * grad * (1 / sqrt(accum))
  var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    accum: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `var`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `var`.
      L2 regularization. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, updating of the var and accum tensors will be protected by
      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyProximalAdagrad = ...
def apply_proximal_adagrad_eager_fallback(var: Annotated[Any, TV_ApplyProximalAdagrad_T], accum: Annotated[Any, TV_ApplyProximalAdagrad_T], lr: Annotated[Any, TV_ApplyProximalAdagrad_T], l1: Annotated[Any, TV_ApplyProximalAdagrad_T], l2: Annotated[Any, TV_ApplyProximalAdagrad_T], grad: Annotated[Any, TV_ApplyProximalAdagrad_T], use_locking: bool, name, ctx) -> Annotated[Any, TV_ApplyProximalAdagrad_T]:
  ...

TV_ApplyProximalGradientDescent_T = TypeVar("TV_ApplyProximalGradientDescent_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_proximal_gradient_descent(var: Annotated[Any, TV_ApplyProximalGradientDescent_T], alpha: Annotated[Any, TV_ApplyProximalGradientDescent_T], l1: Annotated[Any, TV_ApplyProximalGradientDescent_T], l2: Annotated[Any, TV_ApplyProximalGradientDescent_T], delta: Annotated[Any, TV_ApplyProximalGradientDescent_T], use_locking: bool = ..., name=...) -> Annotated[Any, TV_ApplyProximalGradientDescent_T]:
  r"""Update '*var' as FOBOS algorithm with fixed learning rate.

  prox_v = var - alpha * delta
  var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    alpha: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `var`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `var`.
      L2 regularization. Must be a scalar.
    delta: A `Tensor`. Must have the same type as `var`. The change.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, the subtraction will be protected by a lock;
      otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyProximalGradientDescent = ...
def apply_proximal_gradient_descent_eager_fallback(var: Annotated[Any, TV_ApplyProximalGradientDescent_T], alpha: Annotated[Any, TV_ApplyProximalGradientDescent_T], l1: Annotated[Any, TV_ApplyProximalGradientDescent_T], l2: Annotated[Any, TV_ApplyProximalGradientDescent_T], delta: Annotated[Any, TV_ApplyProximalGradientDescent_T], use_locking: bool, name, ctx) -> Annotated[Any, TV_ApplyProximalGradientDescent_T]:
  ...

TV_ApplyRMSProp_T = TypeVar("TV_ApplyRMSProp_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def apply_rms_prop(var: Annotated[Any, TV_ApplyRMSProp_T], ms: Annotated[Any, TV_ApplyRMSProp_T], mom: Annotated[Any, TV_ApplyRMSProp_T], lr: Annotated[Any, TV_ApplyRMSProp_T], rho: Annotated[Any, TV_ApplyRMSProp_T], momentum: Annotated[Any, TV_ApplyRMSProp_T], epsilon: Annotated[Any, TV_ApplyRMSProp_T], grad: Annotated[Any, TV_ApplyRMSProp_T], use_locking: bool = ..., name=...) -> Annotated[Any, TV_ApplyRMSProp_T]:
  r"""Update '*var' according to the RMSProp algorithm.

  Note that in dense implementation of this algorithm, ms and mom will
  update even if the grad is zero, but in this sparse implementation, ms
  and mom will not update in iterations during which the grad is zero.

  mean_square = decay * mean_square + (1-decay) * gradient ** 2
  Delta = learning_rate * gradient / sqrt(mean_square + epsilon)

  ms <- rho * ms_{t-1} + (1-rho) * grad * grad
  mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
  var <- var - mom

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    ms: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    mom: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    rho: A `Tensor`. Must have the same type as `var`.
      Decay rate. Must be a scalar.
    momentum: A `Tensor`. Must have the same type as `var`.
    epsilon: A `Tensor`. Must have the same type as `var`.
      Ridge term. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var, ms, and mom tensors is protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

ApplyRMSProp = ...
def apply_rms_prop_eager_fallback(var: Annotated[Any, TV_ApplyRMSProp_T], ms: Annotated[Any, TV_ApplyRMSProp_T], mom: Annotated[Any, TV_ApplyRMSProp_T], lr: Annotated[Any, TV_ApplyRMSProp_T], rho: Annotated[Any, TV_ApplyRMSProp_T], momentum: Annotated[Any, TV_ApplyRMSProp_T], epsilon: Annotated[Any, TV_ApplyRMSProp_T], grad: Annotated[Any, TV_ApplyRMSProp_T], use_locking: bool, name, ctx) -> Annotated[Any, TV_ApplyRMSProp_T]:
  ...

TV_ResourceApplyAdaMax_T = TypeVar("TV_ResourceApplyAdaMax_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_ada_max(var: Annotated[Any, _atypes.Resource], m: Annotated[Any, _atypes.Resource], v: Annotated[Any, _atypes.Resource], beta1_power: Annotated[Any, TV_ResourceApplyAdaMax_T], lr: Annotated[Any, TV_ResourceApplyAdaMax_T], beta1: Annotated[Any, TV_ResourceApplyAdaMax_T], beta2: Annotated[Any, TV_ResourceApplyAdaMax_T], epsilon: Annotated[Any, TV_ResourceApplyAdaMax_T], grad: Annotated[Any, TV_ResourceApplyAdaMax_T], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the AdaMax algorithm.

  m_t <- beta1 * m_{t-1} + (1 - beta1) * g
  v_t <- max(beta2 * v_{t-1}, abs(g))
  variable <- variable - learning_rate / (1 - beta1^t) * m_t / (v_t + epsilon)

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    m: A `Tensor` of type `resource`. Should be from a Variable().
    v: A `Tensor` of type `resource`. Should be from a Variable().
    beta1_power: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Must be a scalar.
    lr: A `Tensor`. Must have the same type as `beta1_power`.
      Scaling factor. Must be a scalar.
    beta1: A `Tensor`. Must have the same type as `beta1_power`.
      Momentum factor. Must be a scalar.
    beta2: A `Tensor`. Must have the same type as `beta1_power`.
      Momentum factor. Must be a scalar.
    epsilon: A `Tensor`. Must have the same type as `beta1_power`.
      Ridge term. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `beta1_power`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var, m, and v tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyAdaMax = ...
def resource_apply_ada_max_eager_fallback(var: Annotated[Any, _atypes.Resource], m: Annotated[Any, _atypes.Resource], v: Annotated[Any, _atypes.Resource], beta1_power: Annotated[Any, TV_ResourceApplyAdaMax_T], lr: Annotated[Any, TV_ResourceApplyAdaMax_T], beta1: Annotated[Any, TV_ResourceApplyAdaMax_T], beta2: Annotated[Any, TV_ResourceApplyAdaMax_T], epsilon: Annotated[Any, TV_ResourceApplyAdaMax_T], grad: Annotated[Any, TV_ResourceApplyAdaMax_T], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyAdadelta_T = TypeVar("TV_ResourceApplyAdadelta_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_adadelta(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], accum_update: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyAdadelta_T], rho: Annotated[Any, TV_ResourceApplyAdadelta_T], epsilon: Annotated[Any, TV_ResourceApplyAdadelta_T], grad: Annotated[Any, TV_ResourceApplyAdadelta_T], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the adadelta scheme.

  accum = rho() * accum + (1 - rho()) * grad.square();
  update = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;
  update_accum = rho() * update_accum + (1 - rho()) * update.square();
  var -= update;

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    accum_update: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Scaling factor. Must be a scalar.
    rho: A `Tensor`. Must have the same type as `lr`.
      Decay factor. Must be a scalar.
    epsilon: A `Tensor`. Must have the same type as `lr`.
      Constant factor. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, updating of the var, accum and update_accum tensors will be protected by
      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyAdadelta = ...
def resource_apply_adadelta_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], accum_update: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyAdadelta_T], rho: Annotated[Any, TV_ResourceApplyAdadelta_T], epsilon: Annotated[Any, TV_ResourceApplyAdadelta_T], grad: Annotated[Any, TV_ResourceApplyAdadelta_T], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyAdagrad_T = TypeVar("TV_ResourceApplyAdagrad_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_adagrad(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyAdagrad_T], grad: Annotated[Any, TV_ResourceApplyAdagrad_T], use_locking: bool = ..., update_slots: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the adagrad scheme.

  accum += grad * grad
  var -= lr * grad * (1 / sqrt(accum))

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Scaling factor. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    update_slots: An optional `bool`. Defaults to `True`.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyAdagrad = ...
def resource_apply_adagrad_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyAdagrad_T], grad: Annotated[Any, TV_ResourceApplyAdagrad_T], use_locking: bool, update_slots: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyAdagradDA_T = TypeVar("TV_ResourceApplyAdagradDA_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_adagrad_da(var: Annotated[Any, _atypes.Resource], gradient_accumulator: Annotated[Any, _atypes.Resource], gradient_squared_accumulator: Annotated[Any, _atypes.Resource], grad: Annotated[Any, TV_ResourceApplyAdagradDA_T], lr: Annotated[Any, TV_ResourceApplyAdagradDA_T], l1: Annotated[Any, TV_ResourceApplyAdagradDA_T], l2: Annotated[Any, TV_ResourceApplyAdagradDA_T], global_step: Annotated[Any, _atypes.Int64], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the proximal adagrad scheme.

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    gradient_accumulator: A `Tensor` of type `resource`.
      Should be from a Variable().
    gradient_squared_accumulator: A `Tensor` of type `resource`.
      Should be from a Variable().
    grad: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      The gradient.
    lr: A `Tensor`. Must have the same type as `grad`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `grad`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `grad`.
      L2 regularization. Must be a scalar.
    global_step: A `Tensor` of type `int64`.
      Training step number. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, updating of the var and accum tensors will be protected by
      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyAdagradDA = ...
def resource_apply_adagrad_da_eager_fallback(var: Annotated[Any, _atypes.Resource], gradient_accumulator: Annotated[Any, _atypes.Resource], gradient_squared_accumulator: Annotated[Any, _atypes.Resource], grad: Annotated[Any, TV_ResourceApplyAdagradDA_T], lr: Annotated[Any, TV_ResourceApplyAdagradDA_T], l1: Annotated[Any, TV_ResourceApplyAdagradDA_T], l2: Annotated[Any, TV_ResourceApplyAdagradDA_T], global_step: Annotated[Any, _atypes.Int64], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyAdagradV2_T = TypeVar("TV_ResourceApplyAdagradV2_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_adagrad_v2(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyAdagradV2_T], epsilon: Annotated[Any, TV_ResourceApplyAdagradV2_T], grad: Annotated[Any, TV_ResourceApplyAdagradV2_T], use_locking: bool = ..., update_slots: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the adagrad scheme.

  accum += grad * grad
  var -= lr * grad * (1 / (sqrt(accum) + epsilon))

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Scaling factor. Must be a scalar.
    epsilon: A `Tensor`. Must have the same type as `lr`.
      Constant factor. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    update_slots: An optional `bool`. Defaults to `True`.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyAdagradV2 = ...
def resource_apply_adagrad_v2_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyAdagradV2_T], epsilon: Annotated[Any, TV_ResourceApplyAdagradV2_T], grad: Annotated[Any, TV_ResourceApplyAdagradV2_T], use_locking: bool, update_slots: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyAdam_T = TypeVar("TV_ResourceApplyAdam_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_adam(var: Annotated[Any, _atypes.Resource], m: Annotated[Any, _atypes.Resource], v: Annotated[Any, _atypes.Resource], beta1_power: Annotated[Any, TV_ResourceApplyAdam_T], beta2_power: Annotated[Any, TV_ResourceApplyAdam_T], lr: Annotated[Any, TV_ResourceApplyAdam_T], beta1: Annotated[Any, TV_ResourceApplyAdam_T], beta2: Annotated[Any, TV_ResourceApplyAdam_T], epsilon: Annotated[Any, TV_ResourceApplyAdam_T], grad: Annotated[Any, TV_ResourceApplyAdam_T], use_locking: bool = ..., use_nesterov: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the Adam algorithm.

  $$\text{lr}_t := \mathrm{lr} \cdot \frac{\sqrt{1 - \beta_2^t}}{1 - \beta_1^t}$$
  $$m_t := \beta_1 \cdot m_{t-1} + (1 - \beta_1) \cdot g$$
  $$v_t := \beta_2 \cdot v_{t-1} + (1 - \beta_2) \cdot g^2$$
  $$\text{var} := \begin{cases} \text{var} - (m_t \beta_1 + g \cdot (1 - \beta_1))\cdot\text{lr}_t/(\sqrt{v_t} + \epsilon), &\text{if use_nesterov}\\\\  \text{var} - m_t \cdot \text{lr}_t /(\sqrt{v_t} + \epsilon), &\text{otherwise} \end{cases}$$

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    m: A `Tensor` of type `resource`. Should be from a Variable().
    v: A `Tensor` of type `resource`. Should be from a Variable().
    beta1_power: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Must be a scalar.
    beta2_power: A `Tensor`. Must have the same type as `beta1_power`.
      Must be a scalar.
    lr: A `Tensor`. Must have the same type as `beta1_power`.
      Scaling factor. Must be a scalar.
    beta1: A `Tensor`. Must have the same type as `beta1_power`.
      Momentum factor. Must be a scalar.
    beta2: A `Tensor`. Must have the same type as `beta1_power`.
      Momentum factor. Must be a scalar.
    epsilon: A `Tensor`. Must have the same type as `beta1_power`.
      Ridge term. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `beta1_power`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var, m, and v tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    use_nesterov: An optional `bool`. Defaults to `False`.
      If `True`, uses the nesterov update.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyAdam = ...
def resource_apply_adam_eager_fallback(var: Annotated[Any, _atypes.Resource], m: Annotated[Any, _atypes.Resource], v: Annotated[Any, _atypes.Resource], beta1_power: Annotated[Any, TV_ResourceApplyAdam_T], beta2_power: Annotated[Any, TV_ResourceApplyAdam_T], lr: Annotated[Any, TV_ResourceApplyAdam_T], beta1: Annotated[Any, TV_ResourceApplyAdam_T], beta2: Annotated[Any, TV_ResourceApplyAdam_T], epsilon: Annotated[Any, TV_ResourceApplyAdam_T], grad: Annotated[Any, TV_ResourceApplyAdam_T], use_locking: bool, use_nesterov: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyAdamWithAmsgrad_T = TypeVar("TV_ResourceApplyAdamWithAmsgrad_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_adam_with_amsgrad(var: Annotated[Any, _atypes.Resource], m: Annotated[Any, _atypes.Resource], v: Annotated[Any, _atypes.Resource], vhat: Annotated[Any, _atypes.Resource], beta1_power: Annotated[Any, TV_ResourceApplyAdamWithAmsgrad_T], beta2_power: Annotated[Any, TV_ResourceApplyAdamWithAmsgrad_T], lr: Annotated[Any, TV_ResourceApplyAdamWithAmsgrad_T], beta1: Annotated[Any, TV_ResourceApplyAdamWithAmsgrad_T], beta2: Annotated[Any, TV_ResourceApplyAdamWithAmsgrad_T], epsilon: Annotated[Any, TV_ResourceApplyAdamWithAmsgrad_T], grad: Annotated[Any, TV_ResourceApplyAdamWithAmsgrad_T], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the Adam algorithm.

  $$\text{lr}_t := \mathrm{learning_rate} * \sqrt{1 - \beta_2^t} / (1 - \beta_1^t)$$
  $$m_t := \beta_1 * m_{t-1} + (1 - \beta_1) * g$$
  $$v_t := \beta_2 * v_{t-1} + (1 - \beta_2) * g * g$$
  $$\hat{v}_t := max{\hat{v}_{t-1}, v_t}$$
  $$\text{variable} := \text{variable} - \text{lr}_t * m_t / (\sqrt{\hat{v}_t} + \epsilon)$$

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    m: A `Tensor` of type `resource`. Should be from a Variable().
    v: A `Tensor` of type `resource`. Should be from a Variable().
    vhat: A `Tensor` of type `resource`. Should be from a Variable().
    beta1_power: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Must be a scalar.
    beta2_power: A `Tensor`. Must have the same type as `beta1_power`.
      Must be a scalar.
    lr: A `Tensor`. Must have the same type as `beta1_power`.
      Scaling factor. Must be a scalar.
    beta1: A `Tensor`. Must have the same type as `beta1_power`.
      Momentum factor. Must be a scalar.
    beta2: A `Tensor`. Must have the same type as `beta1_power`.
      Momentum factor. Must be a scalar.
    epsilon: A `Tensor`. Must have the same type as `beta1_power`.
      Ridge term. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `beta1_power`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var, m, and v tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyAdamWithAmsgrad = ...
def resource_apply_adam_with_amsgrad_eager_fallback(var: Annotated[Any, _atypes.Resource], m: Annotated[Any, _atypes.Resource], v: Annotated[Any, _atypes.Resource], vhat: Annotated[Any, _atypes.Resource], beta1_power: Annotated[Any, TV_ResourceApplyAdamWithAmsgrad_T], beta2_power: Annotated[Any, TV_ResourceApplyAdamWithAmsgrad_T], lr: Annotated[Any, TV_ResourceApplyAdamWithAmsgrad_T], beta1: Annotated[Any, TV_ResourceApplyAdamWithAmsgrad_T], beta2: Annotated[Any, TV_ResourceApplyAdamWithAmsgrad_T], epsilon: Annotated[Any, TV_ResourceApplyAdamWithAmsgrad_T], grad: Annotated[Any, TV_ResourceApplyAdamWithAmsgrad_T], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyAddSign_T = TypeVar("TV_ResourceApplyAddSign_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_add_sign(var: Annotated[Any, _atypes.Resource], m: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyAddSign_T], alpha: Annotated[Any, TV_ResourceApplyAddSign_T], sign_decay: Annotated[Any, TV_ResourceApplyAddSign_T], beta: Annotated[Any, TV_ResourceApplyAddSign_T], grad: Annotated[Any, TV_ResourceApplyAddSign_T], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the AddSign update.

  m_t <- beta1 * m_{t-1} + (1 - beta1) * g
  update <- (alpha + sign_decay * sign(g) *sign(m)) * g
  variable <- variable - lr_t * update

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    m: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Scaling factor. Must be a scalar.
    alpha: A `Tensor`. Must have the same type as `lr`. Must be a scalar.
    sign_decay: A `Tensor`. Must have the same type as `lr`. Must be a scalar.
    beta: A `Tensor`. Must have the same type as `lr`. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and m tensors is
      protected by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyAddSign = ...
def resource_apply_add_sign_eager_fallback(var: Annotated[Any, _atypes.Resource], m: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyAddSign_T], alpha: Annotated[Any, TV_ResourceApplyAddSign_T], sign_decay: Annotated[Any, TV_ResourceApplyAddSign_T], beta: Annotated[Any, TV_ResourceApplyAddSign_T], grad: Annotated[Any, TV_ResourceApplyAddSign_T], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyCenteredRMSProp_T = TypeVar("TV_ResourceApplyCenteredRMSProp_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_centered_rms_prop(var: Annotated[Any, _atypes.Resource], mg: Annotated[Any, _atypes.Resource], ms: Annotated[Any, _atypes.Resource], mom: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyCenteredRMSProp_T], rho: Annotated[Any, TV_ResourceApplyCenteredRMSProp_T], momentum: Annotated[Any, TV_ResourceApplyCenteredRMSProp_T], epsilon: Annotated[Any, TV_ResourceApplyCenteredRMSProp_T], grad: Annotated[Any, TV_ResourceApplyCenteredRMSProp_T], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the centered RMSProp algorithm.

  The centered RMSProp algorithm uses an estimate of the centered second moment
  (i.e., the variance) for normalization, as opposed to regular RMSProp, which
  uses the (uncentered) second moment. This often helps with training, but is
  slightly more expensive in terms of computation and memory.

  Note that in dense implementation of this algorithm, mg, ms, and mom will
  update even if the grad is zero, but in this sparse implementation, mg, ms,
  and mom will not update in iterations during which the grad is zero.

  mean_square = decay * mean_square + (1-decay) * gradient ** 2
  mean_grad = decay * mean_grad + (1-decay) * gradient

  Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)

  mg <- rho * mg_{t-1} + (1-rho) * grad
  ms <- rho * ms_{t-1} + (1-rho) * grad * grad
  mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)
  var <- var - mom

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    mg: A `Tensor` of type `resource`. Should be from a Variable().
    ms: A `Tensor` of type `resource`. Should be from a Variable().
    mom: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Scaling factor. Must be a scalar.
    rho: A `Tensor`. Must have the same type as `lr`.
      Decay rate. Must be a scalar.
    momentum: A `Tensor`. Must have the same type as `lr`.
      Momentum Scale. Must be a scalar.
    epsilon: A `Tensor`. Must have the same type as `lr`.
      Ridge term. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var, mg, ms, and mom tensors is
      protected by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyCenteredRMSProp = ...
def resource_apply_centered_rms_prop_eager_fallback(var: Annotated[Any, _atypes.Resource], mg: Annotated[Any, _atypes.Resource], ms: Annotated[Any, _atypes.Resource], mom: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyCenteredRMSProp_T], rho: Annotated[Any, TV_ResourceApplyCenteredRMSProp_T], momentum: Annotated[Any, TV_ResourceApplyCenteredRMSProp_T], epsilon: Annotated[Any, TV_ResourceApplyCenteredRMSProp_T], grad: Annotated[Any, TV_ResourceApplyCenteredRMSProp_T], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyFtrl_T = TypeVar("TV_ResourceApplyFtrl_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_ftrl(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], linear: Annotated[Any, _atypes.Resource], grad: Annotated[Any, TV_ResourceApplyFtrl_T], lr: Annotated[Any, TV_ResourceApplyFtrl_T], l1: Annotated[Any, TV_ResourceApplyFtrl_T], l2: Annotated[Any, TV_ResourceApplyFtrl_T], lr_power: Annotated[Any, TV_ResourceApplyFtrl_T], use_locking: bool = ..., multiply_linear_by_lr: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the Ftrl-proximal scheme.

  accum_new = accum + grad * grad
  linear += grad - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
  quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
  var = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0
  accum = accum_new

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    linear: A `Tensor` of type `resource`. Should be from a Variable().
    grad: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      The gradient.
    lr: A `Tensor`. Must have the same type as `grad`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `grad`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `grad`.
      L2 regularization. Must be a scalar.
    lr_power: A `Tensor`. Must have the same type as `grad`.
      Scaling factor. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    multiply_linear_by_lr: An optional `bool`. Defaults to `False`.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyFtrl = ...
def resource_apply_ftrl_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], linear: Annotated[Any, _atypes.Resource], grad: Annotated[Any, TV_ResourceApplyFtrl_T], lr: Annotated[Any, TV_ResourceApplyFtrl_T], l1: Annotated[Any, TV_ResourceApplyFtrl_T], l2: Annotated[Any, TV_ResourceApplyFtrl_T], lr_power: Annotated[Any, TV_ResourceApplyFtrl_T], use_locking: bool, multiply_linear_by_lr: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyFtrlV2_T = TypeVar("TV_ResourceApplyFtrlV2_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_ftrl_v2(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], linear: Annotated[Any, _atypes.Resource], grad: Annotated[Any, TV_ResourceApplyFtrlV2_T], lr: Annotated[Any, TV_ResourceApplyFtrlV2_T], l1: Annotated[Any, TV_ResourceApplyFtrlV2_T], l2: Annotated[Any, TV_ResourceApplyFtrlV2_T], l2_shrinkage: Annotated[Any, TV_ResourceApplyFtrlV2_T], lr_power: Annotated[Any, TV_ResourceApplyFtrlV2_T], use_locking: bool = ..., multiply_linear_by_lr: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the Ftrl-proximal scheme.

  accum_new = accum + grad * grad
  grad_with_shrinkage = grad + 2 * l2_shrinkage * var
  linear += grad_with_shrinkage +
      (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
  quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
  var = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0
  accum = accum_new

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    linear: A `Tensor` of type `resource`. Should be from a Variable().
    grad: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      The gradient.
    lr: A `Tensor`. Must have the same type as `grad`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `grad`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `grad`.
      L2 shrinkage regularization. Must be a scalar.
    l2_shrinkage: A `Tensor`. Must have the same type as `grad`.
    lr_power: A `Tensor`. Must have the same type as `grad`.
      Scaling factor. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    multiply_linear_by_lr: An optional `bool`. Defaults to `False`.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyFtrlV2 = ...
def resource_apply_ftrl_v2_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], linear: Annotated[Any, _atypes.Resource], grad: Annotated[Any, TV_ResourceApplyFtrlV2_T], lr: Annotated[Any, TV_ResourceApplyFtrlV2_T], l1: Annotated[Any, TV_ResourceApplyFtrlV2_T], l2: Annotated[Any, TV_ResourceApplyFtrlV2_T], l2_shrinkage: Annotated[Any, TV_ResourceApplyFtrlV2_T], lr_power: Annotated[Any, TV_ResourceApplyFtrlV2_T], use_locking: bool, multiply_linear_by_lr: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyGradientDescent_T = TypeVar("TV_ResourceApplyGradientDescent_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_gradient_descent(var: Annotated[Any, _atypes.Resource], alpha: Annotated[Any, TV_ResourceApplyGradientDescent_T], delta: Annotated[Any, TV_ResourceApplyGradientDescent_T], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' by subtracting 'alpha' * 'delta' from it.

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    alpha: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Scaling factor. Must be a scalar.
    delta: A `Tensor`. Must have the same type as `alpha`. The change.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, the subtraction will be protected by a lock;
      otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyGradientDescent = ...
def resource_apply_gradient_descent_eager_fallback(var: Annotated[Any, _atypes.Resource], alpha: Annotated[Any, TV_ResourceApplyGradientDescent_T], delta: Annotated[Any, TV_ResourceApplyGradientDescent_T], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyKerasMomentum_T = TypeVar("TV_ResourceApplyKerasMomentum_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_keras_momentum(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyKerasMomentum_T], grad: Annotated[Any, TV_ResourceApplyKerasMomentum_T], momentum: Annotated[Any, TV_ResourceApplyKerasMomentum_T], use_locking: bool = ..., use_nesterov: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the momentum scheme.

  Set use_nesterov = True if you want to use Nesterov momentum.

  accum = accum * momentum - lr * grad
  var += accum

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Scaling factor. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    momentum: A `Tensor`. Must have the same type as `lr`.
      Momentum. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    use_nesterov: An optional `bool`. Defaults to `False`.
      If `True`, the tensor passed to compute grad will be
      var + momentum * accum, so in the end, the var you get is actually
      var + momentum * accum.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyKerasMomentum = ...
def resource_apply_keras_momentum_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyKerasMomentum_T], grad: Annotated[Any, TV_ResourceApplyKerasMomentum_T], momentum: Annotated[Any, TV_ResourceApplyKerasMomentum_T], use_locking: bool, use_nesterov: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyMomentum_T = TypeVar("TV_ResourceApplyMomentum_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_momentum(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyMomentum_T], grad: Annotated[Any, TV_ResourceApplyMomentum_T], momentum: Annotated[Any, TV_ResourceApplyMomentum_T], use_locking: bool = ..., use_nesterov: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the momentum scheme.

  Set use_nesterov = True if you want to use Nesterov momentum.

  accum = accum * momentum + grad
  var -= lr * accum

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Scaling factor. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    momentum: A `Tensor`. Must have the same type as `lr`.
      Momentum. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    use_nesterov: An optional `bool`. Defaults to `False`.
      If `True`, the tensor passed to compute grad will be
      var - lr * momentum * accum, so in the end, the var you get is actually
      var - lr * momentum * accum.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyMomentum = ...
def resource_apply_momentum_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyMomentum_T], grad: Annotated[Any, TV_ResourceApplyMomentum_T], momentum: Annotated[Any, TV_ResourceApplyMomentum_T], use_locking: bool, use_nesterov: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyPowerSign_T = TypeVar("TV_ResourceApplyPowerSign_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_power_sign(var: Annotated[Any, _atypes.Resource], m: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyPowerSign_T], logbase: Annotated[Any, TV_ResourceApplyPowerSign_T], sign_decay: Annotated[Any, TV_ResourceApplyPowerSign_T], beta: Annotated[Any, TV_ResourceApplyPowerSign_T], grad: Annotated[Any, TV_ResourceApplyPowerSign_T], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the AddSign update.

  m_t <- beta1 * m_{t-1} + (1 - beta1) * g
  update <- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g
  variable <- variable - lr_t * update

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    m: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Scaling factor. Must be a scalar.
    logbase: A `Tensor`. Must have the same type as `lr`. Must be a scalar.
    sign_decay: A `Tensor`. Must have the same type as `lr`. Must be a scalar.
    beta: A `Tensor`. Must have the same type as `lr`. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and m tensors is
      protected by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyPowerSign = ...
def resource_apply_power_sign_eager_fallback(var: Annotated[Any, _atypes.Resource], m: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyPowerSign_T], logbase: Annotated[Any, TV_ResourceApplyPowerSign_T], sign_decay: Annotated[Any, TV_ResourceApplyPowerSign_T], beta: Annotated[Any, TV_ResourceApplyPowerSign_T], grad: Annotated[Any, TV_ResourceApplyPowerSign_T], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyProximalAdagrad_T = TypeVar("TV_ResourceApplyProximalAdagrad_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_proximal_adagrad(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyProximalAdagrad_T], l1: Annotated[Any, TV_ResourceApplyProximalAdagrad_T], l2: Annotated[Any, TV_ResourceApplyProximalAdagrad_T], grad: Annotated[Any, TV_ResourceApplyProximalAdagrad_T], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' and '*accum' according to FOBOS with Adagrad learning rate.

  accum += grad * grad
  prox_v = var - lr * grad * (1 / sqrt(accum))
  var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `lr`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `lr`.
      L2 regularization. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, updating of the var and accum tensors will be protected by
      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyProximalAdagrad = ...
def resource_apply_proximal_adagrad_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyProximalAdagrad_T], l1: Annotated[Any, TV_ResourceApplyProximalAdagrad_T], l2: Annotated[Any, TV_ResourceApplyProximalAdagrad_T], grad: Annotated[Any, TV_ResourceApplyProximalAdagrad_T], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyProximalGradientDescent_T = TypeVar("TV_ResourceApplyProximalGradientDescent_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_proximal_gradient_descent(var: Annotated[Any, _atypes.Resource], alpha: Annotated[Any, TV_ResourceApplyProximalGradientDescent_T], l1: Annotated[Any, TV_ResourceApplyProximalGradientDescent_T], l2: Annotated[Any, TV_ResourceApplyProximalGradientDescent_T], delta: Annotated[Any, TV_ResourceApplyProximalGradientDescent_T], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' as FOBOS algorithm with fixed learning rate.

  prox_v = var - alpha * delta
  var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    alpha: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `alpha`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `alpha`.
      L2 regularization. Must be a scalar.
    delta: A `Tensor`. Must have the same type as `alpha`. The change.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, the subtraction will be protected by a lock;
      otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyProximalGradientDescent = ...
def resource_apply_proximal_gradient_descent_eager_fallback(var: Annotated[Any, _atypes.Resource], alpha: Annotated[Any, TV_ResourceApplyProximalGradientDescent_T], l1: Annotated[Any, TV_ResourceApplyProximalGradientDescent_T], l2: Annotated[Any, TV_ResourceApplyProximalGradientDescent_T], delta: Annotated[Any, TV_ResourceApplyProximalGradientDescent_T], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceApplyRMSProp_T = TypeVar("TV_ResourceApplyRMSProp_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
def resource_apply_rms_prop(var: Annotated[Any, _atypes.Resource], ms: Annotated[Any, _atypes.Resource], mom: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyRMSProp_T], rho: Annotated[Any, TV_ResourceApplyRMSProp_T], momentum: Annotated[Any, TV_ResourceApplyRMSProp_T], epsilon: Annotated[Any, TV_ResourceApplyRMSProp_T], grad: Annotated[Any, TV_ResourceApplyRMSProp_T], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the RMSProp algorithm.

  Note that in dense implementation of this algorithm, ms and mom will
  update even if the grad is zero, but in this sparse implementation, ms
  and mom will not update in iterations during which the grad is zero.

  mean_square = decay * mean_square + (1-decay) * gradient ** 2
  Delta = learning_rate * gradient / sqrt(mean_square + epsilon)

  ms <- rho * ms_{t-1} + (1-rho) * grad * grad
  mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
  var <- var - mom

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    ms: A `Tensor` of type `resource`. Should be from a Variable().
    mom: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Scaling factor. Must be a scalar.
    rho: A `Tensor`. Must have the same type as `lr`.
      Decay rate. Must be a scalar.
    momentum: A `Tensor`. Must have the same type as `lr`.
    epsilon: A `Tensor`. Must have the same type as `lr`.
      Ridge term. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var, ms, and mom tensors is protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceApplyRMSProp = ...
def resource_apply_rms_prop_eager_fallback(var: Annotated[Any, _atypes.Resource], ms: Annotated[Any, _atypes.Resource], mom: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceApplyRMSProp_T], rho: Annotated[Any, TV_ResourceApplyRMSProp_T], momentum: Annotated[Any, TV_ResourceApplyRMSProp_T], epsilon: Annotated[Any, TV_ResourceApplyRMSProp_T], grad: Annotated[Any, TV_ResourceApplyRMSProp_T], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceSparseApplyAdadelta_T = TypeVar("TV_ResourceSparseApplyAdadelta_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_ResourceSparseApplyAdadelta_Tindices = TypeVar("TV_ResourceSparseApplyAdadelta_Tindices", _atypes.Int32, _atypes.Int64)
def resource_sparse_apply_adadelta(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], accum_update: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyAdadelta_T], rho: Annotated[Any, TV_ResourceSparseApplyAdadelta_T], epsilon: Annotated[Any, TV_ResourceSparseApplyAdadelta_T], grad: Annotated[Any, TV_ResourceSparseApplyAdadelta_T], indices: Annotated[Any, TV_ResourceSparseApplyAdadelta_Tindices], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""var: Should be from a Variable().

  Args:
    var: A `Tensor` of type `resource`.
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    accum_update: A `Tensor` of type `resource`.
      : Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Learning rate. Must be a scalar.
    rho: A `Tensor`. Must have the same type as `lr`.
      Decay factor. Must be a scalar.
    epsilon: A `Tensor`. Must have the same type as `lr`.
      Constant factor. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, updating of the var and accum tensors will be protected by
      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceSparseApplyAdadelta = ...
def resource_sparse_apply_adadelta_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], accum_update: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyAdadelta_T], rho: Annotated[Any, TV_ResourceSparseApplyAdadelta_T], epsilon: Annotated[Any, TV_ResourceSparseApplyAdadelta_T], grad: Annotated[Any, TV_ResourceSparseApplyAdadelta_T], indices: Annotated[Any, TV_ResourceSparseApplyAdadelta_Tindices], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceSparseApplyAdagrad_T = TypeVar("TV_ResourceSparseApplyAdagrad_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_ResourceSparseApplyAdagrad_Tindices = TypeVar("TV_ResourceSparseApplyAdagrad_Tindices", _atypes.Int32, _atypes.Int64)
def resource_sparse_apply_adagrad(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyAdagrad_T], grad: Annotated[Any, TV_ResourceSparseApplyAdagrad_T], indices: Annotated[Any, TV_ResourceSparseApplyAdagrad_Tindices], use_locking: bool = ..., update_slots: bool = ..., name=...): # -> object | Operation | None:
  r"""Update relevant entries in '*var' and '*accum' according to the adagrad scheme.

  That is for rows we have grad for, we update var and accum as follows:
  accum += grad * grad
  var -= lr * grad * (1 / sqrt(accum))

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Learning rate. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    update_slots: An optional `bool`. Defaults to `True`.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceSparseApplyAdagrad = ...
def resource_sparse_apply_adagrad_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyAdagrad_T], grad: Annotated[Any, TV_ResourceSparseApplyAdagrad_T], indices: Annotated[Any, TV_ResourceSparseApplyAdagrad_Tindices], use_locking: bool, update_slots: bool, name, ctx): # -> None:
  ...

TV_ResourceSparseApplyAdagradDA_T = TypeVar("TV_ResourceSparseApplyAdagradDA_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_ResourceSparseApplyAdagradDA_Tindices = TypeVar("TV_ResourceSparseApplyAdagradDA_Tindices", _atypes.Int32, _atypes.Int64)
def resource_sparse_apply_adagrad_da(var: Annotated[Any, _atypes.Resource], gradient_accumulator: Annotated[Any, _atypes.Resource], gradient_squared_accumulator: Annotated[Any, _atypes.Resource], grad: Annotated[Any, TV_ResourceSparseApplyAdagradDA_T], indices: Annotated[Any, TV_ResourceSparseApplyAdagradDA_Tindices], lr: Annotated[Any, TV_ResourceSparseApplyAdagradDA_T], l1: Annotated[Any, TV_ResourceSparseApplyAdagradDA_T], l2: Annotated[Any, TV_ResourceSparseApplyAdagradDA_T], global_step: Annotated[Any, _atypes.Int64], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Update entries in '*var' and '*accum' according to the proximal adagrad scheme.

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    gradient_accumulator: A `Tensor` of type `resource`.
      Should be from a Variable().
    gradient_squared_accumulator: A `Tensor` of type `resource`.
      Should be from a Variable().
    grad: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    lr: A `Tensor`. Must have the same type as `grad`.
      Learning rate. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `grad`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `grad`.
      L2 regularization. Must be a scalar.
    global_step: A `Tensor` of type `int64`.
      Training step number. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, updating of the var and accum tensors will be protected by
      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceSparseApplyAdagradDA = ...
def resource_sparse_apply_adagrad_da_eager_fallback(var: Annotated[Any, _atypes.Resource], gradient_accumulator: Annotated[Any, _atypes.Resource], gradient_squared_accumulator: Annotated[Any, _atypes.Resource], grad: Annotated[Any, TV_ResourceSparseApplyAdagradDA_T], indices: Annotated[Any, TV_ResourceSparseApplyAdagradDA_Tindices], lr: Annotated[Any, TV_ResourceSparseApplyAdagradDA_T], l1: Annotated[Any, TV_ResourceSparseApplyAdagradDA_T], l2: Annotated[Any, TV_ResourceSparseApplyAdagradDA_T], global_step: Annotated[Any, _atypes.Int64], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceSparseApplyAdagradV2_T = TypeVar("TV_ResourceSparseApplyAdagradV2_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_ResourceSparseApplyAdagradV2_Tindices = TypeVar("TV_ResourceSparseApplyAdagradV2_Tindices", _atypes.Int32, _atypes.Int64)
def resource_sparse_apply_adagrad_v2(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyAdagradV2_T], epsilon: Annotated[Any, TV_ResourceSparseApplyAdagradV2_T], grad: Annotated[Any, TV_ResourceSparseApplyAdagradV2_T], indices: Annotated[Any, TV_ResourceSparseApplyAdagradV2_Tindices], use_locking: bool = ..., update_slots: bool = ..., name=...): # -> object | Operation | None:
  r"""Update relevant entries in '*var' and '*accum' according to the adagrad scheme.

  That is for rows we have grad for, we update var and accum as follows:
  accum += grad * grad
  var -= lr * grad * (1 / sqrt(accum))

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Learning rate. Must be a scalar.
    epsilon: A `Tensor`. Must have the same type as `lr`.
      Constant factor. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    update_slots: An optional `bool`. Defaults to `True`.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceSparseApplyAdagradV2 = ...
def resource_sparse_apply_adagrad_v2_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyAdagradV2_T], epsilon: Annotated[Any, TV_ResourceSparseApplyAdagradV2_T], grad: Annotated[Any, TV_ResourceSparseApplyAdagradV2_T], indices: Annotated[Any, TV_ResourceSparseApplyAdagradV2_Tindices], use_locking: bool, update_slots: bool, name, ctx): # -> None:
  ...

TV_ResourceSparseApplyCenteredRMSProp_T = TypeVar("TV_ResourceSparseApplyCenteredRMSProp_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_ResourceSparseApplyCenteredRMSProp_Tindices = TypeVar("TV_ResourceSparseApplyCenteredRMSProp_Tindices", _atypes.Int32, _atypes.Int64)
def resource_sparse_apply_centered_rms_prop(var: Annotated[Any, _atypes.Resource], mg: Annotated[Any, _atypes.Resource], ms: Annotated[Any, _atypes.Resource], mom: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyCenteredRMSProp_T], rho: Annotated[Any, TV_ResourceSparseApplyCenteredRMSProp_T], momentum: Annotated[Any, TV_ResourceSparseApplyCenteredRMSProp_T], epsilon: Annotated[Any, TV_ResourceSparseApplyCenteredRMSProp_T], grad: Annotated[Any, TV_ResourceSparseApplyCenteredRMSProp_T], indices: Annotated[Any, TV_ResourceSparseApplyCenteredRMSProp_Tindices], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the centered RMSProp algorithm.

  The centered RMSProp algorithm uses an estimate of the centered second moment
  (i.e., the variance) for normalization, as opposed to regular RMSProp, which
  uses the (uncentered) second moment. This often helps with training, but is
  slightly more expensive in terms of computation and memory.

  Note that in dense implementation of this algorithm, mg, ms, and mom will
  update even if the grad is zero, but in this sparse implementation, mg, ms,
  and mom will not update in iterations during which the grad is zero.

  mean_square = decay * mean_square + (1-decay) * gradient ** 2
  mean_grad = decay * mean_grad + (1-decay) * gradient
  Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)

  ms <- rho * ms_{t-1} + (1-rho) * grad * grad
  mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
  var <- var - mom

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    mg: A `Tensor` of type `resource`. Should be from a Variable().
    ms: A `Tensor` of type `resource`. Should be from a Variable().
    mom: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Scaling factor. Must be a scalar.
    rho: A `Tensor`. Must have the same type as `lr`.
      Decay rate. Must be a scalar.
    momentum: A `Tensor`. Must have the same type as `lr`.
    epsilon: A `Tensor`. Must have the same type as `lr`.
      Ridge term. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var, ms and mom.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var, mg, ms, and mom tensors is
      protected by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceSparseApplyCenteredRMSProp = ...
def resource_sparse_apply_centered_rms_prop_eager_fallback(var: Annotated[Any, _atypes.Resource], mg: Annotated[Any, _atypes.Resource], ms: Annotated[Any, _atypes.Resource], mom: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyCenteredRMSProp_T], rho: Annotated[Any, TV_ResourceSparseApplyCenteredRMSProp_T], momentum: Annotated[Any, TV_ResourceSparseApplyCenteredRMSProp_T], epsilon: Annotated[Any, TV_ResourceSparseApplyCenteredRMSProp_T], grad: Annotated[Any, TV_ResourceSparseApplyCenteredRMSProp_T], indices: Annotated[Any, TV_ResourceSparseApplyCenteredRMSProp_Tindices], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceSparseApplyFtrl_T = TypeVar("TV_ResourceSparseApplyFtrl_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_ResourceSparseApplyFtrl_Tindices = TypeVar("TV_ResourceSparseApplyFtrl_Tindices", _atypes.Int32, _atypes.Int64)
def resource_sparse_apply_ftrl(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], linear: Annotated[Any, _atypes.Resource], grad: Annotated[Any, TV_ResourceSparseApplyFtrl_T], indices: Annotated[Any, TV_ResourceSparseApplyFtrl_Tindices], lr: Annotated[Any, TV_ResourceSparseApplyFtrl_T], l1: Annotated[Any, TV_ResourceSparseApplyFtrl_T], l2: Annotated[Any, TV_ResourceSparseApplyFtrl_T], lr_power: Annotated[Any, TV_ResourceSparseApplyFtrl_T], use_locking: bool = ..., multiply_linear_by_lr: bool = ..., name=...): # -> object | Operation | None:
  r"""Update relevant entries in '*var' according to the Ftrl-proximal scheme.

  That is for rows we have grad for, we update var, accum and linear as follows:
  accum_new = accum + grad * grad
  linear += grad - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
  quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
  var = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0
  accum = accum_new

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    linear: A `Tensor` of type `resource`. Should be from a Variable().
    grad: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    lr: A `Tensor`. Must have the same type as `grad`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `grad`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `grad`.
      L2 regularization. Must be a scalar.
    lr_power: A `Tensor`. Must have the same type as `grad`.
      Scaling factor. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    multiply_linear_by_lr: An optional `bool`. Defaults to `False`.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceSparseApplyFtrl = ...
def resource_sparse_apply_ftrl_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], linear: Annotated[Any, _atypes.Resource], grad: Annotated[Any, TV_ResourceSparseApplyFtrl_T], indices: Annotated[Any, TV_ResourceSparseApplyFtrl_Tindices], lr: Annotated[Any, TV_ResourceSparseApplyFtrl_T], l1: Annotated[Any, TV_ResourceSparseApplyFtrl_T], l2: Annotated[Any, TV_ResourceSparseApplyFtrl_T], lr_power: Annotated[Any, TV_ResourceSparseApplyFtrl_T], use_locking: bool, multiply_linear_by_lr: bool, name, ctx): # -> None:
  ...

TV_ResourceSparseApplyFtrlV2_T = TypeVar("TV_ResourceSparseApplyFtrlV2_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_ResourceSparseApplyFtrlV2_Tindices = TypeVar("TV_ResourceSparseApplyFtrlV2_Tindices", _atypes.Int32, _atypes.Int64)
def resource_sparse_apply_ftrl_v2(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], linear: Annotated[Any, _atypes.Resource], grad: Annotated[Any, TV_ResourceSparseApplyFtrlV2_T], indices: Annotated[Any, TV_ResourceSparseApplyFtrlV2_Tindices], lr: Annotated[Any, TV_ResourceSparseApplyFtrlV2_T], l1: Annotated[Any, TV_ResourceSparseApplyFtrlV2_T], l2: Annotated[Any, TV_ResourceSparseApplyFtrlV2_T], l2_shrinkage: Annotated[Any, TV_ResourceSparseApplyFtrlV2_T], lr_power: Annotated[Any, TV_ResourceSparseApplyFtrlV2_T], use_locking: bool = ..., multiply_linear_by_lr: bool = ..., name=...): # -> object | Operation | None:
  r"""Update relevant entries in '*var' according to the Ftrl-proximal scheme.

  That is for rows we have grad for, we update var, accum and linear as follows:
  grad_with_shrinkage = grad + 2 * l2_shrinkage * var
  accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
  linear += grad_with_shrinkage +
      (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
  quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
  var = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0
  accum = accum_new

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    linear: A `Tensor` of type `resource`. Should be from a Variable().
    grad: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    lr: A `Tensor`. Must have the same type as `grad`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `grad`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `grad`.
      L2 shrinkage regularization. Must be a scalar.
    l2_shrinkage: A `Tensor`. Must have the same type as `grad`.
    lr_power: A `Tensor`. Must have the same type as `grad`.
      Scaling factor. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    multiply_linear_by_lr: An optional `bool`. Defaults to `False`.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceSparseApplyFtrlV2 = ...
def resource_sparse_apply_ftrl_v2_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], linear: Annotated[Any, _atypes.Resource], grad: Annotated[Any, TV_ResourceSparseApplyFtrlV2_T], indices: Annotated[Any, TV_ResourceSparseApplyFtrlV2_Tindices], lr: Annotated[Any, TV_ResourceSparseApplyFtrlV2_T], l1: Annotated[Any, TV_ResourceSparseApplyFtrlV2_T], l2: Annotated[Any, TV_ResourceSparseApplyFtrlV2_T], l2_shrinkage: Annotated[Any, TV_ResourceSparseApplyFtrlV2_T], lr_power: Annotated[Any, TV_ResourceSparseApplyFtrlV2_T], use_locking: bool, multiply_linear_by_lr: bool, name, ctx): # -> None:
  ...

TV_ResourceSparseApplyKerasMomentum_T = TypeVar("TV_ResourceSparseApplyKerasMomentum_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_ResourceSparseApplyKerasMomentum_Tindices = TypeVar("TV_ResourceSparseApplyKerasMomentum_Tindices", _atypes.Int32, _atypes.Int64)
def resource_sparse_apply_keras_momentum(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyKerasMomentum_T], grad: Annotated[Any, TV_ResourceSparseApplyKerasMomentum_T], indices: Annotated[Any, TV_ResourceSparseApplyKerasMomentum_Tindices], momentum: Annotated[Any, TV_ResourceSparseApplyKerasMomentum_T], use_locking: bool = ..., use_nesterov: bool = ..., name=...): # -> object | Operation | None:
  r"""Update relevant entries in '*var' and '*accum' according to the momentum scheme.

  Set use_nesterov = True if you want to use Nesterov momentum.

  That is for rows we have grad for, we update var and accum as follows:

  accum = accum * momentum - lr * grad
  var += accum

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Learning rate. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    momentum: A `Tensor`. Must have the same type as `lr`.
      Momentum. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    use_nesterov: An optional `bool`. Defaults to `False`.
      If `True`, the tensor passed to compute grad will be
      var + momentum * accum, so in the end, the var you get is actually
      var + momentum * accum.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceSparseApplyKerasMomentum = ...
def resource_sparse_apply_keras_momentum_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyKerasMomentum_T], grad: Annotated[Any, TV_ResourceSparseApplyKerasMomentum_T], indices: Annotated[Any, TV_ResourceSparseApplyKerasMomentum_Tindices], momentum: Annotated[Any, TV_ResourceSparseApplyKerasMomentum_T], use_locking: bool, use_nesterov: bool, name, ctx): # -> None:
  ...

TV_ResourceSparseApplyMomentum_T = TypeVar("TV_ResourceSparseApplyMomentum_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_ResourceSparseApplyMomentum_Tindices = TypeVar("TV_ResourceSparseApplyMomentum_Tindices", _atypes.Int32, _atypes.Int64)
def resource_sparse_apply_momentum(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyMomentum_T], grad: Annotated[Any, TV_ResourceSparseApplyMomentum_T], indices: Annotated[Any, TV_ResourceSparseApplyMomentum_Tindices], momentum: Annotated[Any, TV_ResourceSparseApplyMomentum_T], use_locking: bool = ..., use_nesterov: bool = ..., name=...): # -> object | Operation | None:
  r"""Update relevant entries in '*var' and '*accum' according to the momentum scheme.

  Set use_nesterov = True if you want to use Nesterov momentum.

  That is for rows we have grad for, we update var and accum as follows:

  accum = accum * momentum + grad
  var -= lr * accum

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Learning rate. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    momentum: A `Tensor`. Must have the same type as `lr`.
      Momentum. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    use_nesterov: An optional `bool`. Defaults to `False`.
      If `True`, the tensor passed to compute grad will be
      var - lr * momentum * accum, so in the end, the var you get is actually
      var - lr * momentum * accum.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceSparseApplyMomentum = ...
def resource_sparse_apply_momentum_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyMomentum_T], grad: Annotated[Any, TV_ResourceSparseApplyMomentum_T], indices: Annotated[Any, TV_ResourceSparseApplyMomentum_Tindices], momentum: Annotated[Any, TV_ResourceSparseApplyMomentum_T], use_locking: bool, use_nesterov: bool, name, ctx): # -> None:
  ...

TV_ResourceSparseApplyProximalAdagrad_T = TypeVar("TV_ResourceSparseApplyProximalAdagrad_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_ResourceSparseApplyProximalAdagrad_Tindices = TypeVar("TV_ResourceSparseApplyProximalAdagrad_Tindices", _atypes.Int32, _atypes.Int64)
def resource_sparse_apply_proximal_adagrad(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyProximalAdagrad_T], l1: Annotated[Any, TV_ResourceSparseApplyProximalAdagrad_T], l2: Annotated[Any, TV_ResourceSparseApplyProximalAdagrad_T], grad: Annotated[Any, TV_ResourceSparseApplyProximalAdagrad_T], indices: Annotated[Any, TV_ResourceSparseApplyProximalAdagrad_Tindices], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Sparse update entries in '*var' and '*accum' according to FOBOS algorithm.

  That is for rows we have grad for, we update var and accum as follows:
  accum += grad * grad
  prox_v = var
  prox_v -= lr * grad * (1 / sqrt(accum))
  var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    accum: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Learning rate. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `lr`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `lr`.
      L2 regularization. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, updating of the var and accum tensors will be protected by
      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceSparseApplyProximalAdagrad = ...
def resource_sparse_apply_proximal_adagrad_eager_fallback(var: Annotated[Any, _atypes.Resource], accum: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyProximalAdagrad_T], l1: Annotated[Any, TV_ResourceSparseApplyProximalAdagrad_T], l2: Annotated[Any, TV_ResourceSparseApplyProximalAdagrad_T], grad: Annotated[Any, TV_ResourceSparseApplyProximalAdagrad_T], indices: Annotated[Any, TV_ResourceSparseApplyProximalAdagrad_Tindices], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceSparseApplyProximalGradientDescent_T = TypeVar("TV_ResourceSparseApplyProximalGradientDescent_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_ResourceSparseApplyProximalGradientDescent_Tindices = TypeVar("TV_ResourceSparseApplyProximalGradientDescent_Tindices", _atypes.Int32, _atypes.Int64)
def resource_sparse_apply_proximal_gradient_descent(var: Annotated[Any, _atypes.Resource], alpha: Annotated[Any, TV_ResourceSparseApplyProximalGradientDescent_T], l1: Annotated[Any, TV_ResourceSparseApplyProximalGradientDescent_T], l2: Annotated[Any, TV_ResourceSparseApplyProximalGradientDescent_T], grad: Annotated[Any, TV_ResourceSparseApplyProximalGradientDescent_T], indices: Annotated[Any, TV_ResourceSparseApplyProximalGradientDescent_Tindices], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Sparse update '*var' as FOBOS algorithm with fixed learning rate.

  That is for rows we have grad for, we update var as follows:
  prox_v = var - alpha * grad
  var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    alpha: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `alpha`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `alpha`.
      L2 regularization. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `alpha`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, the subtraction will be protected by a lock;
      otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceSparseApplyProximalGradientDescent = ...
def resource_sparse_apply_proximal_gradient_descent_eager_fallback(var: Annotated[Any, _atypes.Resource], alpha: Annotated[Any, TV_ResourceSparseApplyProximalGradientDescent_T], l1: Annotated[Any, TV_ResourceSparseApplyProximalGradientDescent_T], l2: Annotated[Any, TV_ResourceSparseApplyProximalGradientDescent_T], grad: Annotated[Any, TV_ResourceSparseApplyProximalGradientDescent_T], indices: Annotated[Any, TV_ResourceSparseApplyProximalGradientDescent_Tindices], use_locking: bool, name, ctx): # -> None:
  ...

TV_ResourceSparseApplyRMSProp_T = TypeVar("TV_ResourceSparseApplyRMSProp_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_ResourceSparseApplyRMSProp_Tindices = TypeVar("TV_ResourceSparseApplyRMSProp_Tindices", _atypes.Int32, _atypes.Int64)
def resource_sparse_apply_rms_prop(var: Annotated[Any, _atypes.Resource], ms: Annotated[Any, _atypes.Resource], mom: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyRMSProp_T], rho: Annotated[Any, TV_ResourceSparseApplyRMSProp_T], momentum: Annotated[Any, TV_ResourceSparseApplyRMSProp_T], epsilon: Annotated[Any, TV_ResourceSparseApplyRMSProp_T], grad: Annotated[Any, TV_ResourceSparseApplyRMSProp_T], indices: Annotated[Any, TV_ResourceSparseApplyRMSProp_Tindices], use_locking: bool = ..., name=...): # -> object | Operation | None:
  r"""Update '*var' according to the RMSProp algorithm.

  Note that in dense implementation of this algorithm, ms and mom will
  update even if the grad is zero, but in this sparse implementation, ms
  and mom will not update in iterations during which the grad is zero.

  mean_square = decay * mean_square + (1-decay) * gradient ** 2
  Delta = learning_rate * gradient / sqrt(mean_square + epsilon)

  ms <- rho * ms_{t-1} + (1-rho) * grad * grad
  mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
  var <- var - mom

  Args:
    var: A `Tensor` of type `resource`. Should be from a Variable().
    ms: A `Tensor` of type `resource`. Should be from a Variable().
    mom: A `Tensor` of type `resource`. Should be from a Variable().
    lr: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Scaling factor. Must be a scalar.
    rho: A `Tensor`. Must have the same type as `lr`.
      Decay rate. Must be a scalar.
    momentum: A `Tensor`. Must have the same type as `lr`.
    epsilon: A `Tensor`. Must have the same type as `lr`.
      Ridge term. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `lr`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var, ms and mom.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var, ms, and mom tensors is protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

ResourceSparseApplyRMSProp = ...
def resource_sparse_apply_rms_prop_eager_fallback(var: Annotated[Any, _atypes.Resource], ms: Annotated[Any, _atypes.Resource], mom: Annotated[Any, _atypes.Resource], lr: Annotated[Any, TV_ResourceSparseApplyRMSProp_T], rho: Annotated[Any, TV_ResourceSparseApplyRMSProp_T], momentum: Annotated[Any, TV_ResourceSparseApplyRMSProp_T], epsilon: Annotated[Any, TV_ResourceSparseApplyRMSProp_T], grad: Annotated[Any, TV_ResourceSparseApplyRMSProp_T], indices: Annotated[Any, TV_ResourceSparseApplyRMSProp_Tindices], use_locking: bool, name, ctx): # -> None:
  ...

TV_SparseApplyAdadelta_T = TypeVar("TV_SparseApplyAdadelta_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_SparseApplyAdadelta_Tindices = TypeVar("TV_SparseApplyAdadelta_Tindices", _atypes.Int32, _atypes.Int64)
def sparse_apply_adadelta(var: Annotated[Any, TV_SparseApplyAdadelta_T], accum: Annotated[Any, TV_SparseApplyAdadelta_T], accum_update: Annotated[Any, TV_SparseApplyAdadelta_T], lr: Annotated[Any, TV_SparseApplyAdadelta_T], rho: Annotated[Any, TV_SparseApplyAdadelta_T], epsilon: Annotated[Any, TV_SparseApplyAdadelta_T], grad: Annotated[Any, TV_SparseApplyAdadelta_T], indices: Annotated[Any, TV_SparseApplyAdadelta_Tindices], use_locking: bool = ..., name=...) -> Annotated[Any, TV_SparseApplyAdadelta_T]:
  r"""var: Should be from a Variable().

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
    accum: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    accum_update: A mutable `Tensor`. Must have the same type as `var`.
      : Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Learning rate. Must be a scalar.
    rho: A `Tensor`. Must have the same type as `var`.
      Decay factor. Must be a scalar.
    epsilon: A `Tensor`. Must have the same type as `var`.
      Constant factor. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, updating of the var and accum tensors will be protected by
      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

SparseApplyAdadelta = ...
def sparse_apply_adadelta_eager_fallback(var: Annotated[Any, TV_SparseApplyAdadelta_T], accum: Annotated[Any, TV_SparseApplyAdadelta_T], accum_update: Annotated[Any, TV_SparseApplyAdadelta_T], lr: Annotated[Any, TV_SparseApplyAdadelta_T], rho: Annotated[Any, TV_SparseApplyAdadelta_T], epsilon: Annotated[Any, TV_SparseApplyAdadelta_T], grad: Annotated[Any, TV_SparseApplyAdadelta_T], indices: Annotated[Any, TV_SparseApplyAdadelta_Tindices], use_locking: bool, name, ctx) -> Annotated[Any, TV_SparseApplyAdadelta_T]:
  ...

TV_SparseApplyAdagrad_T = TypeVar("TV_SparseApplyAdagrad_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_SparseApplyAdagrad_Tindices = TypeVar("TV_SparseApplyAdagrad_Tindices", _atypes.Int32, _atypes.Int64)
def sparse_apply_adagrad(var: Annotated[Any, TV_SparseApplyAdagrad_T], accum: Annotated[Any, TV_SparseApplyAdagrad_T], lr: Annotated[Any, TV_SparseApplyAdagrad_T], grad: Annotated[Any, TV_SparseApplyAdagrad_T], indices: Annotated[Any, TV_SparseApplyAdagrad_Tindices], use_locking: bool = ..., update_slots: bool = ..., name=...) -> Annotated[Any, TV_SparseApplyAdagrad_T]:
  r"""Update relevant entries in '*var' and '*accum' according to the adagrad scheme.

  That is for rows we have grad for, we update var and accum as follows:
  $$accum += grad * grad$$
  $$var -= lr * grad * (1 / sqrt(accum))$$

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    accum: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Learning rate. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    update_slots: An optional `bool`. Defaults to `True`.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

SparseApplyAdagrad = ...
def sparse_apply_adagrad_eager_fallback(var: Annotated[Any, TV_SparseApplyAdagrad_T], accum: Annotated[Any, TV_SparseApplyAdagrad_T], lr: Annotated[Any, TV_SparseApplyAdagrad_T], grad: Annotated[Any, TV_SparseApplyAdagrad_T], indices: Annotated[Any, TV_SparseApplyAdagrad_Tindices], use_locking: bool, update_slots: bool, name, ctx) -> Annotated[Any, TV_SparseApplyAdagrad_T]:
  ...

TV_SparseApplyAdagradDA_T = TypeVar("TV_SparseApplyAdagradDA_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_SparseApplyAdagradDA_Tindices = TypeVar("TV_SparseApplyAdagradDA_Tindices", _atypes.Int32, _atypes.Int64)
def sparse_apply_adagrad_da(var: Annotated[Any, TV_SparseApplyAdagradDA_T], gradient_accumulator: Annotated[Any, TV_SparseApplyAdagradDA_T], gradient_squared_accumulator: Annotated[Any, TV_SparseApplyAdagradDA_T], grad: Annotated[Any, TV_SparseApplyAdagradDA_T], indices: Annotated[Any, TV_SparseApplyAdagradDA_Tindices], lr: Annotated[Any, TV_SparseApplyAdagradDA_T], l1: Annotated[Any, TV_SparseApplyAdagradDA_T], l2: Annotated[Any, TV_SparseApplyAdagradDA_T], global_step: Annotated[Any, _atypes.Int64], use_locking: bool = ..., name=...) -> Annotated[Any, TV_SparseApplyAdagradDA_T]:
  r"""Update entries in '*var' and '*accum' according to the proximal adagrad scheme.

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    gradient_accumulator: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    gradient_squared_accumulator: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    lr: A `Tensor`. Must have the same type as `var`.
      Learning rate. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `var`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `var`.
      L2 regularization. Must be a scalar.
    global_step: A `Tensor` of type `int64`.
      Training step number. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, updating of the var and accum tensors will be protected by
      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

SparseApplyAdagradDA = ...
def sparse_apply_adagrad_da_eager_fallback(var: Annotated[Any, TV_SparseApplyAdagradDA_T], gradient_accumulator: Annotated[Any, TV_SparseApplyAdagradDA_T], gradient_squared_accumulator: Annotated[Any, TV_SparseApplyAdagradDA_T], grad: Annotated[Any, TV_SparseApplyAdagradDA_T], indices: Annotated[Any, TV_SparseApplyAdagradDA_Tindices], lr: Annotated[Any, TV_SparseApplyAdagradDA_T], l1: Annotated[Any, TV_SparseApplyAdagradDA_T], l2: Annotated[Any, TV_SparseApplyAdagradDA_T], global_step: Annotated[Any, _atypes.Int64], use_locking: bool, name, ctx) -> Annotated[Any, TV_SparseApplyAdagradDA_T]:
  ...

TV_SparseApplyAdagradV2_T = TypeVar("TV_SparseApplyAdagradV2_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_SparseApplyAdagradV2_Tindices = TypeVar("TV_SparseApplyAdagradV2_Tindices", _atypes.Int32, _atypes.Int64)
def sparse_apply_adagrad_v2(var: Annotated[Any, TV_SparseApplyAdagradV2_T], accum: Annotated[Any, TV_SparseApplyAdagradV2_T], lr: Annotated[Any, TV_SparseApplyAdagradV2_T], epsilon: Annotated[Any, TV_SparseApplyAdagradV2_T], grad: Annotated[Any, TV_SparseApplyAdagradV2_T], indices: Annotated[Any, TV_SparseApplyAdagradV2_Tindices], use_locking: bool = ..., update_slots: bool = ..., name=...) -> Annotated[Any, TV_SparseApplyAdagradV2_T]:
  r"""Update relevant entries in '*var' and '*accum' according to the adagrad scheme.

  That is for rows we have grad for, we update var and accum as follows:
  $$accum += grad * grad$$
  $$var -= lr * grad * (1 / sqrt(accum))$$

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    accum: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Learning rate. Must be a scalar.
    epsilon: A `Tensor`. Must have the same type as `var`.
      Constant factor. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    update_slots: An optional `bool`. Defaults to `True`.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

SparseApplyAdagradV2 = ...
def sparse_apply_adagrad_v2_eager_fallback(var: Annotated[Any, TV_SparseApplyAdagradV2_T], accum: Annotated[Any, TV_SparseApplyAdagradV2_T], lr: Annotated[Any, TV_SparseApplyAdagradV2_T], epsilon: Annotated[Any, TV_SparseApplyAdagradV2_T], grad: Annotated[Any, TV_SparseApplyAdagradV2_T], indices: Annotated[Any, TV_SparseApplyAdagradV2_Tindices], use_locking: bool, update_slots: bool, name, ctx) -> Annotated[Any, TV_SparseApplyAdagradV2_T]:
  ...

TV_SparseApplyCenteredRMSProp_T = TypeVar("TV_SparseApplyCenteredRMSProp_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_SparseApplyCenteredRMSProp_Tindices = TypeVar("TV_SparseApplyCenteredRMSProp_Tindices", _atypes.Int32, _atypes.Int64)
def sparse_apply_centered_rms_prop(var: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], mg: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], ms: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], mom: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], lr: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], rho: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], momentum: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], epsilon: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], grad: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], indices: Annotated[Any, TV_SparseApplyCenteredRMSProp_Tindices], use_locking: bool = ..., name=...) -> Annotated[Any, TV_SparseApplyCenteredRMSProp_T]:
  r"""Update '*var' according to the centered RMSProp algorithm.

  The centered RMSProp algorithm uses an estimate of the centered second moment
  (i.e., the variance) for normalization, as opposed to regular RMSProp, which
  uses the (uncentered) second moment. This often helps with training, but is
  slightly more expensive in terms of computation and memory.

  Note that in dense implementation of this algorithm, mg, ms, and mom will
  update even if the grad is zero, but in this sparse implementation, mg, ms,
  and mom will not update in iterations during which the grad is zero.

  mean_square = decay * mean_square + (1-decay) * gradient ** 2
  mean_grad = decay * mean_grad + (1-decay) * gradient
  Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)

  $$ms <- rho * ms_{t-1} + (1-rho) * grad * grad$$
  $$mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)$$
  $$var <- var - mom$$

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    mg: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    ms: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    mom: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    rho: A `Tensor`. Must have the same type as `var`.
      Decay rate. Must be a scalar.
    momentum: A `Tensor`. Must have the same type as `var`.
    epsilon: A `Tensor`. Must have the same type as `var`.
      Ridge term. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var, ms and mom.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var, mg, ms, and mom tensors is
      protected by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

SparseApplyCenteredRMSProp = ...
def sparse_apply_centered_rms_prop_eager_fallback(var: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], mg: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], ms: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], mom: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], lr: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], rho: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], momentum: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], epsilon: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], grad: Annotated[Any, TV_SparseApplyCenteredRMSProp_T], indices: Annotated[Any, TV_SparseApplyCenteredRMSProp_Tindices], use_locking: bool, name, ctx) -> Annotated[Any, TV_SparseApplyCenteredRMSProp_T]:
  ...

TV_SparseApplyFtrl_T = TypeVar("TV_SparseApplyFtrl_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_SparseApplyFtrl_Tindices = TypeVar("TV_SparseApplyFtrl_Tindices", _atypes.Int32, _atypes.Int64)
def sparse_apply_ftrl(var: Annotated[Any, TV_SparseApplyFtrl_T], accum: Annotated[Any, TV_SparseApplyFtrl_T], linear: Annotated[Any, TV_SparseApplyFtrl_T], grad: Annotated[Any, TV_SparseApplyFtrl_T], indices: Annotated[Any, TV_SparseApplyFtrl_Tindices], lr: Annotated[Any, TV_SparseApplyFtrl_T], l1: Annotated[Any, TV_SparseApplyFtrl_T], l2: Annotated[Any, TV_SparseApplyFtrl_T], lr_power: Annotated[Any, TV_SparseApplyFtrl_T], use_locking: bool = ..., multiply_linear_by_lr: bool = ..., name=...) -> Annotated[Any, TV_SparseApplyFtrl_T]:
  r"""Update relevant entries in '*var' according to the Ftrl-proximal scheme.

  That is for rows we have grad for, we update var, accum and linear as follows:
  $$accum_new = accum + grad * grad$$
  $$linear += grad + (accum_{new}^{-lr_{power}} - accum^{-lr_{power}} / lr * var$$
  $$quadratic = 1.0 / (accum_{new}^{lr_{power}} * lr) + 2 * l2$$
  $$var = (sign(linear) * l1 - linear) / quadratic\ if\ |linear| > l1\ else\ 0.0$$
  $$accum = accum_{new}$$

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    accum: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    linear: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `var`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `var`.
      L2 regularization. Must be a scalar.
    lr_power: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    multiply_linear_by_lr: An optional `bool`. Defaults to `False`.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

SparseApplyFtrl = ...
def sparse_apply_ftrl_eager_fallback(var: Annotated[Any, TV_SparseApplyFtrl_T], accum: Annotated[Any, TV_SparseApplyFtrl_T], linear: Annotated[Any, TV_SparseApplyFtrl_T], grad: Annotated[Any, TV_SparseApplyFtrl_T], indices: Annotated[Any, TV_SparseApplyFtrl_Tindices], lr: Annotated[Any, TV_SparseApplyFtrl_T], l1: Annotated[Any, TV_SparseApplyFtrl_T], l2: Annotated[Any, TV_SparseApplyFtrl_T], lr_power: Annotated[Any, TV_SparseApplyFtrl_T], use_locking: bool, multiply_linear_by_lr: bool, name, ctx) -> Annotated[Any, TV_SparseApplyFtrl_T]:
  ...

TV_SparseApplyFtrlV2_T = TypeVar("TV_SparseApplyFtrlV2_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_SparseApplyFtrlV2_Tindices = TypeVar("TV_SparseApplyFtrlV2_Tindices", _atypes.Int32, _atypes.Int64)
def sparse_apply_ftrl_v2(var: Annotated[Any, TV_SparseApplyFtrlV2_T], accum: Annotated[Any, TV_SparseApplyFtrlV2_T], linear: Annotated[Any, TV_SparseApplyFtrlV2_T], grad: Annotated[Any, TV_SparseApplyFtrlV2_T], indices: Annotated[Any, TV_SparseApplyFtrlV2_Tindices], lr: Annotated[Any, TV_SparseApplyFtrlV2_T], l1: Annotated[Any, TV_SparseApplyFtrlV2_T], l2: Annotated[Any, TV_SparseApplyFtrlV2_T], l2_shrinkage: Annotated[Any, TV_SparseApplyFtrlV2_T], lr_power: Annotated[Any, TV_SparseApplyFtrlV2_T], use_locking: bool = ..., multiply_linear_by_lr: bool = ..., name=...) -> Annotated[Any, TV_SparseApplyFtrlV2_T]:
  r"""Update relevant entries in '*var' according to the Ftrl-proximal scheme.

  That is for rows we have grad for, we update var, accum and linear as follows:
  grad_with_shrinkage = grad + 2 * l2_shrinkage * var
  accum_new = accum + grad * grad
  linear += grad_with_shrinkage -
      (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
  quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
  var = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0
  accum = accum_new

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    accum: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    linear: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `var`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `var`.
      L2 shrinkage regularization. Must be a scalar.
    l2_shrinkage: A `Tensor`. Must have the same type as `var`.
    lr_power: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    multiply_linear_by_lr: An optional `bool`. Defaults to `False`.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

SparseApplyFtrlV2 = ...
def sparse_apply_ftrl_v2_eager_fallback(var: Annotated[Any, TV_SparseApplyFtrlV2_T], accum: Annotated[Any, TV_SparseApplyFtrlV2_T], linear: Annotated[Any, TV_SparseApplyFtrlV2_T], grad: Annotated[Any, TV_SparseApplyFtrlV2_T], indices: Annotated[Any, TV_SparseApplyFtrlV2_Tindices], lr: Annotated[Any, TV_SparseApplyFtrlV2_T], l1: Annotated[Any, TV_SparseApplyFtrlV2_T], l2: Annotated[Any, TV_SparseApplyFtrlV2_T], l2_shrinkage: Annotated[Any, TV_SparseApplyFtrlV2_T], lr_power: Annotated[Any, TV_SparseApplyFtrlV2_T], use_locking: bool, multiply_linear_by_lr: bool, name, ctx) -> Annotated[Any, TV_SparseApplyFtrlV2_T]:
  ...

TV_SparseApplyMomentum_T = TypeVar("TV_SparseApplyMomentum_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_SparseApplyMomentum_Tindices = TypeVar("TV_SparseApplyMomentum_Tindices", _atypes.Int32, _atypes.Int64)
def sparse_apply_momentum(var: Annotated[Any, TV_SparseApplyMomentum_T], accum: Annotated[Any, TV_SparseApplyMomentum_T], lr: Annotated[Any, TV_SparseApplyMomentum_T], grad: Annotated[Any, TV_SparseApplyMomentum_T], indices: Annotated[Any, TV_SparseApplyMomentum_Tindices], momentum: Annotated[Any, TV_SparseApplyMomentum_T], use_locking: bool = ..., use_nesterov: bool = ..., name=...) -> Annotated[Any, TV_SparseApplyMomentum_T]:
  r"""Update relevant entries in '*var' and '*accum' according to the momentum scheme.

  Set use_nesterov = True if you want to use Nesterov momentum.

  That is for rows we have grad for, we update var and accum as follows:

  $$accum = accum * momentum + grad$$
  $$var -= lr * accum$$

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    accum: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Learning rate. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    momentum: A `Tensor`. Must have the same type as `var`.
      Momentum. Must be a scalar.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var and accum tensors will be protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    use_nesterov: An optional `bool`. Defaults to `False`.
      If `True`, the tensor passed to compute grad will be
      var - lr * momentum * accum, so in the end, the var you get is actually
      var - lr * momentum * accum.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

SparseApplyMomentum = ...
def sparse_apply_momentum_eager_fallback(var: Annotated[Any, TV_SparseApplyMomentum_T], accum: Annotated[Any, TV_SparseApplyMomentum_T], lr: Annotated[Any, TV_SparseApplyMomentum_T], grad: Annotated[Any, TV_SparseApplyMomentum_T], indices: Annotated[Any, TV_SparseApplyMomentum_Tindices], momentum: Annotated[Any, TV_SparseApplyMomentum_T], use_locking: bool, use_nesterov: bool, name, ctx) -> Annotated[Any, TV_SparseApplyMomentum_T]:
  ...

TV_SparseApplyProximalAdagrad_T = TypeVar("TV_SparseApplyProximalAdagrad_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_SparseApplyProximalAdagrad_Tindices = TypeVar("TV_SparseApplyProximalAdagrad_Tindices", _atypes.Int32, _atypes.Int64)
def sparse_apply_proximal_adagrad(var: Annotated[Any, TV_SparseApplyProximalAdagrad_T], accum: Annotated[Any, TV_SparseApplyProximalAdagrad_T], lr: Annotated[Any, TV_SparseApplyProximalAdagrad_T], l1: Annotated[Any, TV_SparseApplyProximalAdagrad_T], l2: Annotated[Any, TV_SparseApplyProximalAdagrad_T], grad: Annotated[Any, TV_SparseApplyProximalAdagrad_T], indices: Annotated[Any, TV_SparseApplyProximalAdagrad_Tindices], use_locking: bool = ..., name=...) -> Annotated[Any, TV_SparseApplyProximalAdagrad_T]:
  r"""Sparse update entries in '*var' and '*accum' according to FOBOS algorithm.

  That is for rows we have grad for, we update var and accum as follows:
  $$accum += grad * grad$$
  $$prox_v = var$$
  $$prox_v -= lr * grad * (1 / sqrt(accum))$$
  $$var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}$$

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    accum: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Learning rate. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `var`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `var`.
      L2 regularization. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, updating of the var and accum tensors will be protected by
      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

SparseApplyProximalAdagrad = ...
def sparse_apply_proximal_adagrad_eager_fallback(var: Annotated[Any, TV_SparseApplyProximalAdagrad_T], accum: Annotated[Any, TV_SparseApplyProximalAdagrad_T], lr: Annotated[Any, TV_SparseApplyProximalAdagrad_T], l1: Annotated[Any, TV_SparseApplyProximalAdagrad_T], l2: Annotated[Any, TV_SparseApplyProximalAdagrad_T], grad: Annotated[Any, TV_SparseApplyProximalAdagrad_T], indices: Annotated[Any, TV_SparseApplyProximalAdagrad_Tindices], use_locking: bool, name, ctx) -> Annotated[Any, TV_SparseApplyProximalAdagrad_T]:
  ...

TV_SparseApplyProximalGradientDescent_T = TypeVar("TV_SparseApplyProximalGradientDescent_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_SparseApplyProximalGradientDescent_Tindices = TypeVar("TV_SparseApplyProximalGradientDescent_Tindices", _atypes.Int32, _atypes.Int64)
def sparse_apply_proximal_gradient_descent(var: Annotated[Any, TV_SparseApplyProximalGradientDescent_T], alpha: Annotated[Any, TV_SparseApplyProximalGradientDescent_T], l1: Annotated[Any, TV_SparseApplyProximalGradientDescent_T], l2: Annotated[Any, TV_SparseApplyProximalGradientDescent_T], grad: Annotated[Any, TV_SparseApplyProximalGradientDescent_T], indices: Annotated[Any, TV_SparseApplyProximalGradientDescent_Tindices], use_locking: bool = ..., name=...) -> Annotated[Any, TV_SparseApplyProximalGradientDescent_T]:
  r"""Sparse update '*var' as FOBOS algorithm with fixed learning rate.

  That is for rows we have grad for, we update var as follows:
  $$prox_v = var - alpha * grad$$
  $$var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}$$

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    alpha: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    l1: A `Tensor`. Must have the same type as `var`.
      L1 regularization. Must be a scalar.
    l2: A `Tensor`. Must have the same type as `var`.
      L2 regularization. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var and accum.
    use_locking: An optional `bool`. Defaults to `False`.
      If True, the subtraction will be protected by a lock;
      otherwise the behavior is undefined, but may exhibit less contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

SparseApplyProximalGradientDescent = ...
def sparse_apply_proximal_gradient_descent_eager_fallback(var: Annotated[Any, TV_SparseApplyProximalGradientDescent_T], alpha: Annotated[Any, TV_SparseApplyProximalGradientDescent_T], l1: Annotated[Any, TV_SparseApplyProximalGradientDescent_T], l2: Annotated[Any, TV_SparseApplyProximalGradientDescent_T], grad: Annotated[Any, TV_SparseApplyProximalGradientDescent_T], indices: Annotated[Any, TV_SparseApplyProximalGradientDescent_Tindices], use_locking: bool, name, ctx) -> Annotated[Any, TV_SparseApplyProximalGradientDescent_T]:
  ...

TV_SparseApplyRMSProp_T = TypeVar("TV_SparseApplyRMSProp_T", _atypes.BFloat16, _atypes.Complex128, _atypes.Complex64, _atypes.Float32, _atypes.Float64, _atypes.Half, _atypes.Int16, _atypes.Int32, _atypes.Int64, _atypes.Int8, _atypes.QInt16, _atypes.QInt32, _atypes.QInt8, _atypes.QUInt16, _atypes.QUInt8, _atypes.UInt16, _atypes.UInt32, _atypes.UInt64, _atypes.UInt8)
TV_SparseApplyRMSProp_Tindices = TypeVar("TV_SparseApplyRMSProp_Tindices", _atypes.Int32, _atypes.Int64)
def sparse_apply_rms_prop(var: Annotated[Any, TV_SparseApplyRMSProp_T], ms: Annotated[Any, TV_SparseApplyRMSProp_T], mom: Annotated[Any, TV_SparseApplyRMSProp_T], lr: Annotated[Any, TV_SparseApplyRMSProp_T], rho: Annotated[Any, TV_SparseApplyRMSProp_T], momentum: Annotated[Any, TV_SparseApplyRMSProp_T], epsilon: Annotated[Any, TV_SparseApplyRMSProp_T], grad: Annotated[Any, TV_SparseApplyRMSProp_T], indices: Annotated[Any, TV_SparseApplyRMSProp_Tindices], use_locking: bool = ..., name=...) -> Annotated[Any, TV_SparseApplyRMSProp_T]:
  r"""Update '*var' according to the RMSProp algorithm.

  Note that in dense implementation of this algorithm, ms and mom will
  update even if the grad is zero, but in this sparse implementation, ms
  and mom will not update in iterations during which the grad is zero.

  mean_square = decay * mean_square + (1-decay) * gradient ** 2
  Delta = learning_rate * gradient / sqrt(mean_square + epsilon)

  $$ms <- rho * ms_{t-1} + (1-rho) * grad * grad$$
  $$mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)$$
  $$var <- var - mom$$

  Args:
    var: A mutable `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `uint8`, `int16`, `int8`, `complex64`, `int64`, `qint8`, `quint8`, `qint32`, `bfloat16`, `qint16`, `quint16`, `uint16`, `complex128`, `half`, `uint32`, `uint64`.
      Should be from a Variable().
    ms: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    mom: A mutable `Tensor`. Must have the same type as `var`.
      Should be from a Variable().
    lr: A `Tensor`. Must have the same type as `var`.
      Scaling factor. Must be a scalar.
    rho: A `Tensor`. Must have the same type as `var`.
      Decay rate. Must be a scalar.
    momentum: A `Tensor`. Must have the same type as `var`.
    epsilon: A `Tensor`. Must have the same type as `var`.
      Ridge term. Must be a scalar.
    grad: A `Tensor`. Must have the same type as `var`. The gradient.
    indices: A `Tensor`. Must be one of the following types: `int32`, `int64`.
      A vector of indices into the first dimension of var, ms and mom.
    use_locking: An optional `bool`. Defaults to `False`.
      If `True`, updating of the var, ms, and mom tensors is protected
      by a lock; otherwise the behavior is undefined, but may exhibit less
      contention.
    name: A name for the operation (optional).

  Returns:
    A mutable `Tensor`. Has the same type as `var`.
  """
  ...

SparseApplyRMSProp = ...
def sparse_apply_rms_prop_eager_fallback(var: Annotated[Any, TV_SparseApplyRMSProp_T], ms: Annotated[Any, TV_SparseApplyRMSProp_T], mom: Annotated[Any, TV_SparseApplyRMSProp_T], lr: Annotated[Any, TV_SparseApplyRMSProp_T], rho: Annotated[Any, TV_SparseApplyRMSProp_T], momentum: Annotated[Any, TV_SparseApplyRMSProp_T], epsilon: Annotated[Any, TV_SparseApplyRMSProp_T], grad: Annotated[Any, TV_SparseApplyRMSProp_T], indices: Annotated[Any, TV_SparseApplyRMSProp_Tindices], use_locking: bool, name, ctx) -> Annotated[Any, TV_SparseApplyRMSProp_T]:
  ...

