"""
This type stub file was generated by pyright.
"""

import abc
import dataclasses
import ml_dtypes
from typing import Optional, Sequence, Type
from tensorflow.core.framework import types_pb2
from tensorflow.python.framework import _dtypes, cpp_shape_inference_pb2
from tensorflow.python.types import trace
from tensorflow.python.util.tf_export import tf_export
from tensorflow.core.function import trace_type
from tensorflow.tools.docs import doc_controls

"""Library of dtypes (Tensor element types)."""
class DTypeMeta(type(_dtypes.DType), abc.ABCMeta):
  ...


@dataclasses.dataclass(frozen=True)
class HandleData:
  """Holds resource/variant tensor specific data."""
  shape_inference: Optional[cpp_shape_inference_pb2.CppShapeInferenceResult.HandleData] = ...
  alias_id: Optional[int] = ...


@tf_export("dtypes.DType", "DType")
class DType(_dtypes.DType, trace.TraceType, trace_type.Serializable, metaclass=DTypeMeta):
  """Represents the type of the elements in a `Tensor`.

  `DType`'s are used to specify the output data type for operations which
  require it, or to inspect the data type of existing `Tensor`'s.

  Examples:

  >>> tf.constant(1, dtype=tf.int64)
  <tf.Tensor: shape=(), dtype=int64, numpy=1>
  >>> tf.constant(1.0).dtype
  tf.float32

  See `tf.dtypes` for a complete list of `DType`'s defined.
  """
  __slots__ = ...
  def __init__(self, type_enum, handle_data=...) -> None:
    ...
  
  @property
  def base_dtype(self): # -> DType | Self:
    """Returns a non-reference `DType` based on this `DType` (for TF1).

    Programs written for TensorFlow 2.x do not need this attribute.
    It exists only for compatibility with TensorFlow 1.x, which used
    reference `DType`s in the implementation of `tf.compat.v1.Variable`.
    In TensorFlow 2.x, `tf.Variable` is implemented without reference types.
    """
    ...
  
  @property
  def real_dtype(self): # -> DType | Self:
    """Returns the `DType` corresponding to this `DType`'s real part."""
    ...
  
  @property
  def as_numpy_dtype(self):
    """Returns a Python `type` object based on this `DType`."""
    ...
  
  @property
  def min(self): # -> Any | floating[Any] | int:
    """Returns the minimum representable value in this data type.

    Raises:
      TypeError: if this is a non-numeric, unordered, or quantized type.

    """
    ...
  
  @property
  def max(self): # -> Any | floating[Any] | int:
    """Returns the maximum representable value in this data type.

    Raises:
      TypeError: if this is a non-numeric, unordered, or quantized type.

    """
    ...
  
  @property
  def limits(self, clip_negative=...): # -> tuple[Any | Literal[0], Any]:
    """Return intensity limits, i.e.

    (min, max) tuple, of the dtype.
    Args:
      clip_negative : bool, optional If True, clip the negative range (i.e.
        return 0 for min intensity) even if the image dtype allows negative
        values. Returns
      min, max : tuple Lower and upper intensity limits.
    """
    ...
  
  def is_compatible_with(self, other): # -> bool:
    """Returns True if the `other` DType will be converted to this DType (TF1).

    Programs written for TensorFlow 2.x do not need this function.
    Instead, they can do equality comparison on `DType` objects directly:
    `tf.as_dtype(this) == tf.as_dtype(other)`.

    This function exists only for compatibility with TensorFlow 1.x, where it
    additionally allows conversion from a reference type (used by
    `tf.compat.v1.Variable`) to its base type.

    Args:
      other: A `DType` (or object that may be converted to a `DType`).

    Returns:
      True if a Tensor of the `other` `DType` will be implicitly converted to
      this `DType`.
    """
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    """See tf.types.experimental.TraceType base class."""
    ...
  
  def most_specific_common_supertype(self, types: Sequence[trace.TraceType]) -> Optional[DType]:
    """See tf.types.experimental.TraceType base class."""
    ...
  
  @doc_controls.do_not_doc_inheritable
  def placeholder_value(self, placeholder_context): # -> Any:
    """See tf.types.experimental.TraceType base class."""
    ...
  
  @doc_controls.do_not_doc_inheritable
  def from_tensors(self, tensors): # -> Any:
    """See tf.types.experimental.TraceType base class."""
    ...
  
  @doc_controls.do_not_doc_inheritable
  def to_tensors(self, value): # -> List[Tensor]:
    """See tf.types.experimental.TraceType base class."""
    ...
  
  @doc_controls.do_not_doc_inheritable
  def flatten(self): # -> List[TraceType]:
    """See tf.types.experimental.TraceType base class."""
    ...
  
  @doc_controls.do_not_doc_inheritable
  def cast(self, value, cast_context): # -> Any:
    """See tf.types.experimental.TraceType base class."""
    ...
  
  @classmethod
  def experimental_type_proto(cls) -> Type[types_pb2.SerializedDType]:
    """Returns the type of proto associated with DType serialization."""
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: types_pb2.SerializedDType) -> DType:
    """Returns a Dtype instance based on the serialized proto."""
    ...
  
  def experimental_as_proto(self) -> types_pb2.SerializedDType:
    """Returns a proto representation of the Dtype instance."""
    ...
  
  def __eq__(self, other) -> bool:
    """Returns True iff this DType refers to the same type as `other`."""
    ...
  
  def __ne__(self, other) -> bool:
    """Returns True iff self != other."""
    ...
  
  __hash__ = ...
  def __reduce__(self): # -> tuple[Callable[..., DType | Any], tuple[str]]:
    ...
  


dtype_range: DType = ...
resource: DType = ...
variant: DType = ...
uint8: DType = ...
uint16: DType = ...
uint32: DType = ...
uint64: DType = ...
int8: DType = ...
int16: DType = ...
int32: DType = ...
int64: DType = ...
float16: DType = ...
half: DType = ...
float32: DType = ...
float64: DType = ...
double: DType = ...
complex64: DType = ...
complex128: DType = ...
string: DType = ...
bool: DType = ...
qint8: DType = ...
qint16: DType = ...
qint32: DType = ...
quint8: DType = ...
quint16: DType = ...
bfloat16: DType = ...
float8_e5m2: DType = ...
float8_e4m3fn: DType = ...
int4: DType = ...
uint4: DType = ...
resource_ref: DType = ...
variant_ref: DType = ...
float16_ref: DType = ...
half_ref: DType = ...
float32_ref: DType = ...
float64_ref: DType = ...
double_ref: DType = ...
int32_ref: DType = ...
uint32_ref: DType = ...
uint8_ref: DType = ...
uint16_ref: DType = ...
int16_ref: DType = ...
int8_ref: DType = ...
string_ref: DType = ...
complex64_ref: DType = ...
complex128_ref: DType = ...
int64_ref: DType = ...
uint64_ref: DType = ...
bool_ref: DType = ...
qint8_ref: DType = ...
quint8_ref: DType = ...
qint16_ref: DType = ...
quint16_ref: DType = ...
qint32_ref: DType = ...
bfloat16_ref: DType = ...
float8_e5m2_ref: DType = ...
float8_e4m3fn_ref: DType = ...
int4_ref: DType = ...
uint4_ref: DType = ...
_INTERN_TABLE = ...
_TYPE_TO_STRING = ...
_STRING_TO_TF = ...
_np_qint8 = ...
_np_quint8 = ...
_np_qint16 = ...
_np_quint16 = ...
_np_qint32 = ...
_np_bfloat16 = ml_dtypes.bfloat16
_np_float8_e4m3fn = ml_dtypes.float8_e4m3fn
_np_float8_e4m3fnuz = ml_dtypes.float8_e4m3fnuz
_np_float8_e4m3b11fnuz = ml_dtypes.float8_e4m3b11fnuz
_np_float8_e5m2 = ml_dtypes.float8_e5m2
_np_float8_e5m2fnuz = ml_dtypes.float8_e5m2fnuz
_np_int4 = ml_dtypes.int4
_np_uint4 = ml_dtypes.uint4
np_resource = ...
_NP_TO_TF = ...
TF_VALUE_DTYPES = ...
_TF_TO_NP = ...
_QUANTIZED_DTYPES_NO_REF = ...
_QUANTIZED_DTYPES_REF = ...
QUANTIZED_DTYPES = ...
_PYTHON_TO_TF = ...
_ANY_TO_TF = ...
@tf_export("dtypes.as_dtype", "as_dtype")
def as_dtype(type_value): # -> DType:
  """Converts the given `type_value` to a `tf.DType`.

  Inputs can be existing `tf.DType` objects, a [`DataType`
  enum](https://www.tensorflow.org/code/tensorflow/core/framework/types.proto),
  a string type name, or a
  [`numpy.dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html).

  Examples:
  >>> tf.as_dtype(2)  # Enum value for float64.
  tf.float64

  >>> tf.as_dtype('float')
  tf.float32

  >>> tf.as_dtype(np.int32)
  tf.int32

  Note: `DType` values are interned (i.e. a single instance of each dtype is
  stored in a map). When passed a new `DType` object, `as_dtype` always returns
  the interned value.

  Args:
    type_value: A value that can be converted to a `tf.DType` object.

  Returns:
    A `DType` corresponding to `type_value`.

  Raises:
    TypeError: If `type_value` cannot be converted to a `DType`.
  """
  ...

