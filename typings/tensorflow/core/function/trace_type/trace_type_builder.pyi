"""
This type stub file was generated by pyright.
"""

from typing import Any, Dict, Hashable, Optional
from tensorflow.python.types import trace

"""Utitiles for Cache Key generation based on Function Trace Type."""
class InternalTracingContext(trace.TracingContext):
  """Container for variables and flags shared across TraceType generation."""
  def __init__(self, is_legacy_signature: bool = ...) -> None:
    ...
  
  def alias_global_id(self, global_id: Hashable) -> Hashable:
    ...
  
  def add_placeholder(self, alias_id: Hashable, variable) -> None:
    ...
  
  def get_placeholder_mapping(self) -> Dict[Hashable, Any]:
    ...
  
  @property
  def is_legacy_signature(self) -> bool:
    """If the value is from a legacy signature representation.

    Legacy signature representations include tf.function.input_signature and
    ConcreteFunction.structured_input_signature.
    """
    ...
  


class InternalPlaceholderContext(trace.PlaceholderContext):
  """Container with mappings shared across TraceTypes for placeholder values."""
  def __init__(self, context_graph=..., placeholder_mapping=..., unnest_only=..., with_none_control_dependencies=..., composite_device_name=...) -> None:
    ...
  
  def has_placeholder(self, alias_id: Hashable) -> bool:
    ...
  
  def get_placeholder(self, alias_id: Hashable) -> Hashable:
    ...
  
  def add_placeholder(self, alias_id: Hashable, placeholder: Hashable) -> None:
    ...
  
  def update_naming_scope(self, naming_scope: Optional[str]) -> None:
    ...
  
  @property
  def naming_scope(self) -> Optional[str]:
    ...
  
  @property
  def context_graph(self): # -> None:
    ...
  
  @property
  def unnest_only(self) -> bool:
    ...
  
  @property
  def with_none_control_dependencies(self) -> bool:
    ...
  
  @property
  def composite_device_name(self) -> Any:
    ...
  


class InternalCastContext(trace.CastContext):
  """Default casting behaviors."""
  def __init__(self, allow_specs=...) -> None:
    ...
  
  @property
  def allow_specs(self) -> bool:
    """Allow TypeSpecs to be casted (instead of the actual CompositeTensors)."""
    ...
  


def from_value(value: Any, context: trace.TracingContext = ...) -> trace.TraceType:
  """Returns a TraceType corresponding to the value based on the context.

  Args:
    value: The value to generate a TraceType for.
    context: The TracingContext to be shared during protocol calls.

  Returns:
    A TraceType object representing the given value.
  """
  ...

