"""
This type stub file was generated by pyright.
"""

import weakref
from typing import Any, Dict as PythonDict, Hashable, List as PythonList, Optional, Sequence, Tuple as PythonTuple, Type
from tensorflow.core.function.trace_type import default_types_pb2, serialization
from tensorflow.python.types import trace

"""TraceType implementations for common Python types."""
TENSOR = ...
def register_tensor_type(tensor_type): # -> None:
  ...

NanMarker = ...
def is_nan(x): # -> bool:
  """Checks if given value is a Python NaN."""
  ...

class Literal(trace.TraceType, serialization.Serializable):
  """Represents a Literal type like bool, int or string."""
  def __init__(self, value: Any) -> None:
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    ...
  
  def most_specific_common_supertype(self, types: Sequence[trace.TraceType]) -> Optional[Literal]:
    ...
  
  @classmethod
  def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedLiteral]:
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: default_types_pb2.SerializedLiteral) -> Literal:
    ...
  
  def experimental_as_proto(self) -> default_types_pb2.SerializedLiteral:
    ...
  
  def placeholder_value(self, placeholder_context) -> Any:
    ...
  
  def cast(self, value: Any, casting_context: Any) -> Any:
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __repr__(self) -> str:
    ...
  


class Weakref(trace.TraceType):
  """Represents weakref of an arbitrary Python object.

  When a function argument is a custom class, instead of making a copy of it
  just for the sake of function cache, a weakref is instead kept to save memory.
  """
  def __init__(self, ref: weakref.ReferenceType) -> None:
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    ...
  
  def most_specific_common_supertype(self, types: Sequence[trace.TraceType]) -> Optional[Weakref]:
    ...
  
  def placeholder_value(self, placeholder_context) -> Any:
    ...
  
  def cast(self, value, _):
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __repr__(self) -> str:
    ...
  


class Tuple(trace.TraceType, serialization.Serializable):
  """Represents a tuple of TraceType objects."""
  def __init__(self, *components: trace.TraceType) -> None:
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    ...
  
  def most_specific_common_supertype(self, others: Sequence[trace.TraceType]) -> Optional[Tuple]:
    """See base class."""
    ...
  
  @classmethod
  def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedTuple]:
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: default_types_pb2.SerializedTuple) -> Tuple:
    ...
  
  def experimental_as_proto(self) -> default_types_pb2.SerializedTuple:
    ...
  
  def placeholder_value(self, placeholder_context) -> Any:
    ...
  
  def to_tensors(self, value) -> Any:
    ...
  
  def from_tensors(self, tensors) -> Any:
    ...
  
  def flatten(self) -> PythonList[trace.TraceType]:
    ...
  
  def cast(self, value: Any, casting_context) -> Any:
    ...
  
  def __eq__(self, other: Any) -> bool:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __repr__(self) -> str:
    ...
  


class List(trace.TraceType, serialization.Serializable):
  """Represents a list of TraceType objects."""
  def __init__(self, *components: trace.TraceType) -> None:
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    ...
  
  def most_specific_common_supertype(self, others: Sequence[trace.TraceType]) -> Optional[Tuple]:
    """See base class."""
    ...
  
  @classmethod
  def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedList]:
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: default_types_pb2.SerializedList) -> List:
    ...
  
  def experimental_as_proto(self) -> default_types_pb2.SerializedList:
    ...
  
  def placeholder_value(self, placeholder_context) -> Any:
    ...
  
  def to_tensors(self, value): # -> Any:
    ...
  
  def from_tensors(self, tensors) -> Any:
    ...
  
  def flatten(self) -> PythonList[trace.TraceType]:
    ...
  
  def cast(self, value: Any, casting_context) -> Any:
    ...
  
  def __eq__(self, other: Any) -> bool:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __repr__(self) -> str:
    ...
  


class NamedTuple(trace.TraceType, serialization.Serializable):
  """Represents a NamedTuple of TraceType objects."""
  def __init__(self, type_name: str, attribute_names: PythonTuple[str], attributes: PythonTuple[trace.TraceType], placeholder_type: Optional[Type[Any]] = ...) -> None:
    ...
  
  @classmethod
  def from_type_and_attributes(cls, named_tuple_type: Any, attributes: PythonTuple[trace.TraceType]) -> NamedTuple:
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    ...
  
  def most_specific_common_supertype(self, others: Sequence[trace.TraceType]) -> Optional[NamedTuple]:
    """See base class."""
    ...
  
  @classmethod
  def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedNamedTuple]:
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: default_types_pb2.SerializedNamedTuple) -> NamedTuple:
    ...
  
  def experimental_as_proto(self) -> default_types_pb2.SerializedNamedTuple:
    ...
  
  def placeholder_value(self, placeholder_context) -> Any:
    ...
  
  def to_tensors(self, value: Any): # -> list[Any]:
    ...
  
  def from_tensors(self, tensors) -> Any:
    ...
  
  def flatten(self) -> PythonList[trace.TraceType]:
    ...
  
  def cast(self, value: Any, casting_context) -> Any:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __eq__(self, other: Any) -> bool:
    ...
  
  def __repr__(self) -> str:
    ...
  


class Attrs(trace.TraceType):
  """Represents a class annotated by attr.s."""
  def __init__(self, type_name: str, attribute_names: PythonTuple[str], attributes: PythonTuple[trace.TraceType], placeholder_type: Optional[Type[Any]] = ...) -> None:
    ...
  
  @classmethod
  def from_type_and_attributes(cls, attrs_type: Any, attributes: PythonTuple[trace.TraceType]) -> Attrs:
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    ...
  
  def most_specific_common_supertype(self, others: Sequence[trace.TraceType]) -> Optional[Attrs]:
    """See base class."""
    ...
  
  @classmethod
  def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedAttrs]:
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: default_types_pb2.SerializedAttrs) -> Attrs:
    ...
  
  def experimental_as_proto(self) -> default_types_pb2.SerializedAttrs:
    ...
  
  def placeholder_value(self, placeholder_context) -> Any:
    ...
  
  def to_tensors(self, value: Any): # -> list[Any]:
    ...
  
  def from_tensors(self, tensors): # -> Any:
    ...
  
  def flatten(self) -> PythonList[trace.TraceType]:
    ...
  
  def cast(self, value: Any, casting_context) -> Any:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __eq__(self, other: Any) -> bool:
    ...
  
  def __repr__(self) -> str:
    ...
  


class Dict(trace.TraceType, serialization.Serializable):
  """Represents a dictionary of TraceType objects.

  Attributes:
    mapping: A mapping from keys to corresponding TraceTypes of the dict values.
  """
  def __init__(self, mapping: PythonDict[Hashable, trace.TraceType], placeholder_type: Optional[Type[Any]] = ...) -> None:
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    """See base class."""
    ...
  
  def most_specific_common_supertype(self, types: Sequence[trace.TraceType]) -> Optional[Dict]:
    """See base class."""
    ...
  
  @classmethod
  def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedDict]:
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: default_types_pb2.SerializedDict) -> Dict:
    ...
  
  def experimental_as_proto(self) -> default_types_pb2.SerializedDict:
    ...
  
  def placeholder_value(self, placeholder_context) -> Any:
    ...
  
  def to_tensors(self, value: Any): # -> list[Any]:
    ...
  
  def from_tensors(self, tensors): # -> dict[Hashable, Any] | Any:
    ...
  
  def flatten(self) -> PythonList[trace.TraceType]:
    ...
  
  def cast(self, value: Any, casting_context) -> Any:
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __repr__(self) -> str:
    ...
  


